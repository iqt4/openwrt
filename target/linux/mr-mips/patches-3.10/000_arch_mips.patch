--- a/arch/mips/Kbuild.platforms
+++ b/arch/mips/Kbuild.platforms
@@ -31,6 +31,7 @@ platforms += sni
 platforms += txx9
 platforms += vr41xx
 platforms += wrppmc
+platforms += rb
 
 # include the platform specific files
 include $(patsubst %, $(srctree)/arch/mips/%/Platform, $(platforms))
--- a/arch/mips/Kconfig
+++ b/arch/mips/Kconfig
@@ -713,6 +713,23 @@ config MIKROTIK_RB532
 	  Support the Mikrotik(tm) RouterBoard 532 series,
 	  based on the IDT RC32434 SoC.
 
+config MIPS_MIKROTIK
+	bool "Support for Mikrotik RB boards"
+	select CEVT_R4K
+	select CSRC_R4K
+	select DMA_NONCOHERENT
+	select HW_HAS_PCI
+	select IRQ_CPU
+	select SYS_HAS_CPU_MIPS32_R1
+	select SYS_HAS_CPU_MIPS32_R2
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+	select SYS_SUPPORTS_BIG_ENDIAN
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select ZONE_DMA
+	select ARCH_REQUIRE_GPIOLIB
+	help
+	  Say Y here to support all Mikrotik mips based routerboards
+
 config WR_PPMC
 	bool "Wind River PPMC board"
 	select CEVT_R4K
@@ -838,6 +855,14 @@ config NLM_XLP_BOARD
 
 endchoice
 
+config SOFT_PCI_IO
+	bool "PCI IO software emulation on RB4xx"
+	depends on MIPS_MIKROTIK
+
+config MAPPED_KERNEL
+	bool "Mapped kernel support"
+	depends on MIPS_MIKROTIK
+
 source "arch/mips/alchemy/Kconfig"
 source "arch/mips/ath79/Kconfig"
 source "arch/mips/bcm47xx/Kconfig"
@@ -1164,6 +1189,7 @@ config MIPS_L1_CACHE_SHIFT
 	default "4" if MACH_DECSTATION || MIKROTIK_RB532 || PMC_MSP4200_EVAL || SOC_RT288X
 	default "6" if MIPS_CPU_SCACHE
 	default "7" if SGI_IP22 || SGI_IP27 || SGI_IP28 || SNI_RM || CPU_CAVIUM_OCTEON
+	default "4" if MIPS_MIKROTIK
 	default "5"
 
 config HAVE_STD_PC_SERIAL_PORT
@@ -1230,7 +1256,7 @@ config CPU_LOONGSON1B
 config CPU_MIPS32_R1
 	bool "MIPS32 Release 1"
 	depends on SYS_HAS_CPU_MIPS32_R1
-	select CPU_HAS_PREFETCH
+#	select CPU_HAS_PREFETCH
 	select CPU_SUPPORTS_32BIT_KERNEL
 	select CPU_SUPPORTS_HIGHMEM
 	help
@@ -1247,7 +1273,7 @@ config CPU_MIPS32_R1
 config CPU_MIPS32_R2
 	bool "MIPS32 Release 2"
 	depends on SYS_HAS_CPU_MIPS32_R2
-	select CPU_HAS_PREFETCH
+#	select CPU_HAS_PREFETCH
 	select CPU_SUPPORTS_32BIT_KERNEL
 	select CPU_SUPPORTS_HIGHMEM
 	select HAVE_KVM
--- a/arch/mips/include/asm/checksum.h
+++ b/arch/mips/include/asm/checksum.h
@@ -14,6 +14,7 @@
 #include <linux/in6.h>
 
 #include <asm/uaccess.h>
+#include <asm/unaligned.h>
 
 /*
  * computes the checksum of a memory block at buff, length len,
@@ -105,23 +106,23 @@ static inline __sum16 ip_fast_csum(const
 	unsigned int csum;
 	int carry;
 
-	csum = word[0];
-	csum += word[1];
-	carry = (csum < word[1]);
+	csum = get_unaligned(word + 0);
+	csum += get_unaligned(word + 1);
+	carry = (csum < get_unaligned(word + 1));
 	csum += carry;
 
-	csum += word[2];
-	carry = (csum < word[2]);
+	csum += get_unaligned(word + 2);
+	carry = (csum < get_unaligned(word + 2));
 	csum += carry;
 
-	csum += word[3];
-	carry = (csum < word[3]);
+	csum += get_unaligned(word + 3);
+	carry = (csum < get_unaligned(word + 3));
 	csum += carry;
 
 	word += 4;
 	do {
-		csum += *word;
-		carry = (csum < *word);
+		csum += get_unaligned(word);
+		carry = (csum < get_unaligned(word));
 		csum += carry;
 		word++;
 	} while (word != stop);
@@ -208,42 +209,90 @@ static __inline__ __sum16 csum_ipv6_magi
 
 	"	addu	%0, %6		# csum\n"
 	"	sltu	$1, %0, %6	\n"
-	"	lw	%1, 0(%2)	# four words source address\n"
+#ifdef __MIPSEL__
+	"	lwl	%1, 3(%2)	# four words source address\n"
+	"	lwr	%1, 0(%2)	# four words source address\n"
+#else
+	"	lwl	%1, 0(%2)	# four words source address\n"
+	"	lwr	%1, 3(%2)	# four words source address\n"
+#endif
 	"	addu	%0, $1		\n"
 	"	addu	%0, %1		\n"
 	"	sltu	$1, %0, %1	\n"
 
-	"	lw	%1, 4(%2)	\n"
+#ifdef __MIPSEL__
+	"	lwl	%1, 7(%2)	\n"
+	"	lwr	%1, 4(%2)	\n"
+#else
+	"	lwl	%1, 4(%2)	\n"
+	"	lwr	%1, 7(%2)	\n"
+#endif
 	"	addu	%0, $1		\n"
 	"	addu	%0, %1		\n"
 	"	sltu	$1, %0, %1	\n"
 
-	"	lw	%1, 8(%2)	\n"
+#ifdef __MIPSEL__
+	"	lwl	%1, 11(%2)	\n"
+	"	lwr	%1, 8(%2)	\n"
+#else
+	"	lwl	%1, 8(%2)	\n"
+	"	lwr	%1, 11(%2)	\n"
+#endif
 	"	addu	%0, $1		\n"
 	"	addu	%0, %1		\n"
 	"	sltu	$1, %0, %1	\n"
 
-	"	lw	%1, 12(%2)	\n"
+#ifdef __MIPSEL__
+	"	lwl	%1, 15(%2)	\n"
+	"	lwr	%1, 12(%2)	\n"
+#else
+	"	lwl	%1, 12(%2)	\n"
+	"	lwr	%1, 15(%2)	\n"
+#endif
 	"	addu	%0, $1		\n"
 	"	addu	%0, %1		\n"
 	"	sltu	$1, %0, %1	\n"
 
-	"	lw	%1, 0(%3)	\n"
+#ifdef __MIPSEL__
+	"	lwl	%1, 3(%3)	\n"
+	"	lwr	%1, 0(%3)	\n"
+#else
+	"	lwl	%1, 0(%3)	\n"
+	"	lwr	%1, 3(%3)	\n"
+#endif
 	"	addu	%0, $1		\n"
 	"	addu	%0, %1		\n"
 	"	sltu	$1, %0, %1	\n"
 
-	"	lw	%1, 4(%3)	\n"
+#ifdef __MIPSEL__
+	"	lwl	%1, 7(%3)	\n"
+	"	lwr	%1, 4(%3)	\n"
+#else
+	"	lwl	%1, 4(%3)	\n"
+	"	lwr	%1, 7(%3)	\n"
+#endif
 	"	addu	%0, $1		\n"
 	"	addu	%0, %1		\n"
 	"	sltu	$1, %0, %1	\n"
 
-	"	lw	%1, 8(%3)	\n"
+#ifdef __MIPSEL__
+	"	lwl	%1, 11(%3)	\n"
+	"	lwr	%1, 8(%3)	\n"
+#else
+	"	lwl	%1, 8(%3)	\n"
+	"	lwr	%1, 11(%3)	\n"
+#endif
 	"	addu	%0, $1		\n"
 	"	addu	%0, %1		\n"
 	"	sltu	$1, %0, %1	\n"
 
-	"	lw	%1, 12(%3)	\n"
+#ifdef __MIPSEL__
+	"	lwl	%1, 15(%3)	\n"
+	"	lwr	%1, 12(%3)	\n"
+#else
+	"	lwl	%1, 12(%3)	\n"
+	"	lwr	%1, 15(%3)	\n"
+#endif
 	"	addu	%0, $1		\n"
 	"	addu	%0, %1		\n"
 	"	sltu	$1, %0, %1	\n"
--- a/arch/mips/include/asm/io.h
+++ b/arch/mips/include/asm/io.h
@@ -206,6 +206,7 @@ static inline void __iomem * __ioremap_m
 		if (!size || last_addr < phys_addr)
 			return NULL;
 
+#ifndef CONFIG_MAPPED_KERNEL
 		/*
 		 * Map uncached objects in the low 512MB of address
 		 * space using KSEG1.
@@ -214,6 +215,7 @@ static inline void __iomem * __ioremap_m
 		    flags == _CACHE_UNCACHED)
 			return (void __iomem *)
 				(unsigned long)CKSEG1ADDR(phys_addr);
+#endif
 	}
 
 	return __ioremap(offset, size, flags);
@@ -625,4 +627,53 @@ extern void (*_dma_cache_inv)(unsigned l
  */
 #define xlate_dev_kmem_ptr(p)	p
 
+#ifdef CONFIG_MIPS_MIKROTIK
+
+unsigned rb500_readl(volatile void __iomem *addr);
+unsigned short rb500_readw(volatile void __iomem *addr);
+unsigned char rb500_readb(volatile void __iomem *addr);
+
+void rb500_writel(unsigned int b, volatile void __iomem *addr);
+void rb500_writew(unsigned short b, volatile void __iomem *addr);
+void rb500_writeb(unsigned char b, volatile void __iomem *addr);
+
+#endif
+
+#ifdef CONFIG_SOFT_PCI_IO
+
+unsigned _pci_inb(unsigned long port);
+unsigned _pci_inw(unsigned long port);
+unsigned _pci_inl(unsigned long port);
+void _pci_outb(unsigned char value, unsigned long port);
+void _pci_outw(unsigned short value, unsigned long port);
+void _pci_outl(unsigned value, unsigned long port);
+
+#define inb	_pci_inb
+#define inb_p	_pci_inb
+#define __mem_inb	_pci_inb
+#define __mem_inb_p	_pci_inb
+#define inw	_pci_inw
+#define inw_p	_pci_inw
+#define __mem_inw	_pci_inw
+#define __mem_inw_p	_pci_inw
+#define inl	_pci_inl
+#define inl_p	_pci_inl
+#define __mem_inl	_pci_inl
+#define __mem_inl_p	_pci_inl
+
+#define outb	_pci_outb
+#define outb_p	_pci_outb
+#define __mem_outb	_pci_outb
+#define __mem_outb_p	_pci_outb
+#define outw	_pci_outw
+#define outw_p	_pci_outw
+#define __mem_outw	_pci_outw
+#define __mem_outw_p	_pci_outw
+#define outl	_pci_outl
+#define outl_p	_pci_outl
+#define __mem_outl	_pci_outl
+#define __mem_outl_p	_pci_outl
+
+#endif
+
 #endif /* _ASM_IO_H */
--- /dev/null
+++ b/arch/mips/include/asm/mach-rb/cpu-feature-overrides.h
@@ -0,0 +1,6 @@
+#ifndef __ASM_MACH_RB_CPU_FEATURE_OVERRIDES_H
+#define __ASM_MACH_RB_CPU_FEATURE_OVERRIDES_H
+
+#define cpu_has_dsp		0
+
+#endif /* __ASM_MACH_RB_CPU_FEATURE_OVERRIDES_H */
--- /dev/null
+++ b/arch/mips/include/asm/mach-rb/irq.h
@@ -0,0 +1,16 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2003 by Ralf Baechle
+ */
+#ifndef __ASM_MACH_RB_IRQ_H
+#define __ASM_MACH_RBC_IRQ_H
+
+#define I8259A_IRQ_BASE 0
+#define MIPS_CPU_IRQ_BASE 0
+
+#define NR_IRQS	168
+
+#endif /* __ASM_MACH_RB_IRQ_H */
--- /dev/null
+++ b/arch/mips/include/asm/mach-rb/kernel-entry-init.h
@@ -0,0 +1,44 @@
+#ifndef __ASM_MACH_RB_KERNEL_ENTRY_H
+#define __ASM_MACH_RB_KERNEL_ENTRY_H
+
+.macro	kernel_entry_setup
+#ifdef CONFIG_MAPPED_KERNEL
+	.set	push
+	.set	mips32r2
+	/* check whether we are running under 0xc0000000 address space */
+	lui	t0, 0xf000
+	bal	1f
+1:	and	t1, ra, t0
+	li	t0, 0xc0000000
+	beq	t0, t1, 2f
+	/* set up 0xc0000000 address space */
+	mtc0	t0, CP0_ENTRYHI
+	li	t0, 0x1f
+	mtc0	t0, CP0_ENTRYLO0
+	li	t0, 0x0010001f
+	mtc0	t0, CP0_ENTRYLO1
+	li	t0, PM_64M
+	mtc0	t0, CP0_PAGEMASK
+	li	t0, 0
+	mtc0	t0, CP0_INDEX
+	li	t0, 2
+	mtc0	t0, CP0_WIRED
+	ehb
+	tlbwi
+
+	li	t0, 0xc8000000
+	mtc0	t0, CP0_ENTRYHI
+	li	t0, 0x0020001f
+	mtc0	t0, CP0_ENTRYLO0
+	li	t0, 0x0030001f
+	mtc0	t0, CP0_ENTRYLO1
+	li	t0, 1
+	mtc0	t0, CP0_INDEX
+	ehb
+	tlbwi
+2:
+	.set	pop
+#endif
+.endm
+
+#endif
--- /dev/null
+++ b/arch/mips/include/asm/mach-rb/kmalloc.h
@@ -0,0 +1,4 @@
+#ifndef __ASM_MACH_RB_KMALLOC_H
+#define __ASM_MACH_RB_KMALLOC_H
+
+#endif
--- /dev/null
+++ b/arch/mips/include/asm/mach-rb/mangle-port.h
@@ -0,0 +1,36 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2003, 2004 Ralf Baechle
+ */
+#ifndef __ASM_MACH_GENERIC_MANGLE_PORT_H
+#define __ASM_MACH_GENERIC_MANGLE_PORT_H
+
+#ifdef CONFIG_CPU_LITTLE_ENDIAN
+
+#define __swizzle_addr_b(port)	(port)
+#define __swizzle_addr_w(port)	(port)
+#define __swizzle_addr_l(port)	(port)
+#define __swizzle_addr_q(port)	(port)
+
+#else
+
+#define __swizzle_addr_b(port)  ((port) ^ 3)
+#define __swizzle_addr_w(port)  ((port) ^ 2)
+#define __swizzle_addr_l(port)  (port)
+#define __swizzle_addr_q(port)  (port)
+
+#endif
+
+#define ioswabb(a,x)		(x)
+#define __mem_ioswabb(a,x)	(x)
+#define ioswabw(a,x)		(x)
+#define __mem_ioswabw(a,x)	cpu_to_le16(x)
+#define ioswabl(a,x)		(x)
+#define __mem_ioswabl(a,x)	cpu_to_le32(x)
+#define ioswabq(a,x)		(x)
+#define __mem_ioswabq(a,x)	cpu_to_le32(x)
+
+#endif /* __ASM_MACH_GENERIC_MANGLE_PORT_H */
--- /dev/null
+++ b/arch/mips/include/asm/mach-rb/spaces.h
@@ -0,0 +1,30 @@
+#ifndef _ASM_MACH_RB_SPACES_H
+#define _ASM_MACH_RB_SPACES_H
+
+#include <linux/const.h>
+
+#define PHYS_OFFSET		_AC(0, UL)
+
+#ifdef CONFIG_MAPPED_KERNEL
+#define CAC_BASE		_AC(0xc0000000, UL)
+#else
+#define CAC_BASE		_AC(0x80000000, UL)
+#endif
+#define IO_BASE			_AC(0xa0000000, UL)
+#define UNCAC_BASE		_AC(0xa0000000, UL)
+
+#ifndef MAP_BASE
+#define MAP_BASE		_AC(0xd0000000, UL)
+#endif
+
+#define HIGHMEM_START		_AC(0x20000000, UL)
+
+#define PAGE_OFFSET		(CAC_BASE + PHYS_OFFSET)
+
+#ifndef CONFIG_MAPPED_KERNEL
+#define FIXADDR_TOP		((unsigned long)(long)(int)0xfffe0000)
+#else
+#define FIXADDR_TOP		((unsigned long)(long)(int)0xdffe0000)
+#endif
+
+#endif
--- /dev/null
+++ b/arch/mips/include/asm/mach-rb/war.h
@@ -0,0 +1,18 @@
+#ifndef __ASM_MIPS_MACH_RB_WAR_H
+#define __ASM_MIPS_MACH_RB_WAR_H
+
+#define R4600_V1_INDEX_ICACHEOP_WAR	0
+#define R4600_V1_HIT_CACHEOP_WAR	0
+#define R4600_V2_HIT_CACHEOP_WAR	0
+#define R5432_CP0_INTERRUPT_WAR		0
+#define BCM1250_M3_WAR			0
+#define SIBYTE_1956_WAR			0
+#define MIPS4K_ICACHE_REFILL_WAR	0
+#define MIPS_CACHE_SYNC_WAR		0
+#define TX49XX_ICACHE_INDEX_INV_WAR	0
+#define RM9000_CDEX_SMP_WAR		0
+#define ICACHE_REFILLS_WORKAROUND_WAR   0
+#define R10000_LLSC_WAR			0
+#define MIPS34K_MISSED_ITLB_WAR		0
+
+#endif
--- /dev/null
+++ b/arch/mips/include/asm/rb/boards.h
@@ -0,0 +1,66 @@
+#ifndef _ASM_RB_BOARDS_H
+#define _ASM_RB_BOARDS_H
+
+#define MACH_GROUP_MT_RB500    1	/* Mikrotik RB500 */
+#define MACH_GROUP_MT_RB100    2	/* Mikrotik RB100 */
+#define MACH_GROUP_MT_CR       3	/* Mikrotik CR */
+#define MACH_GROUP_MT_RB400    4
+#define MACH_GROUP_MT_VM       6
+#define MACH_GROUP_MT_RB700    7
+
+
+#define  MACH_MT_RB500		0
+#define  MACH_MT_RB500R5	1
+#define  MACH_MT_RB100		2
+#define  MACH_MT_RB150		3
+#define  MACH_MT_RB133		4
+#define  MACH_MT_RB133C		5
+#define  MACH_MT_MR		6
+#define  MACH_MT_RB192		7
+#define  MACH_MT_CR1		8
+#define  MACH_MT_RB411		10
+#define  MACH_MT_RB433		11
+#define  MACH_MT_RB433U		12	/* RB433 + USB */
+#define  MACH_MT_RB450		13
+#define  MACH_MT_RB493		15
+#define  MACH_MT_RB450G		16
+#define  MACH_MT_RB411U		17
+#define  MACH_MT_RB493G		18
+#define  MACH_MT_RB750G		19
+#define  MACH_MT_RB435G		20
+#define  MACH_MT_RB750		23
+#define  MACH_MT_RB711		24
+#define  MACH_MT_RB_OMNI	25
+#define  MACH_MT_RB_SXT5D	26
+#define  MACH_MT_RB_GROOVE	27
+#define  MACH_MT_RB_OMNI_5FE	28	/* OmniTIK U-5HnD */
+#define  MACH_MT_RB711R3	29
+#define  MACH_MT_RB751G		30
+#define  MACH_MT_RB711G		31
+#define  MACH_MT_RB411L		33
+#define  MACH_MT_RB750GL	35
+#define  MACH_MT_RB411G		36
+#define  MACH_MT_RB951		37
+#define  MACH_MT_GROOVE52	38
+#define  MACH_MT_RB2011G	39
+#define  MACH_MT_RB912G		40
+#define  MACH_MT_RB433GL	41
+#define  MACH_MT_RB433UL	42
+#define  MACH_MT_RB_SXTG	43
+#define  MACH_MT_RB751		44
+#define  MACH_MT_RB_GROOVE_5S	45
+#define  MACH_MT_RB433L		46
+#define  MACH_MT_RB411UL	47
+#define  MACH_MT_RB2011L	49
+#define  MACH_MT_RB2011LS	50
+#define  MACH_MT_RB951G		52
+#define  MACH_MT_RB2011US	53
+#define  MACH_MT_SXT2D		58
+#define  MACH_MT_SXT5N		59
+#define  MACH_MT_RB2011R5	61
+#define  MACH_MT_CRS125G	63
+
+extern unsigned long mips_machgroup;
+extern unsigned long mips_machtype;
+
+#endif
--- /dev/null
+++ b/arch/mips/include/asm/rb/booter.h
@@ -0,0 +1,19 @@
+#ifndef _ASM_BOOTER_H
+#define _ASM_BOOTER_H
+
+#define ID_HW_OPTIONS		0x00000015
+
+#define HW_OPT_UART_ABSENT	(1 << 0)
+#define HW_OPT_HAS_VOLTAGE	(1 << 1)
+#define HW_OPT_HAS_USB		(1 << 2)
+#define HW_OPT_HAS_ATTINY	(1 << 3)
+#define HW_OPT_NO_NAND		(1 << 14)
+#define HW_OPT_HAS_LCD		(1 << 15)
+#define HW_OPT_HAS_POE_OUT	(1 << 16)
+#define HW_OPT_HAS_uSD		(1 << 17)
+#define HW_OPT_HAS_SFP		(1 << 20)
+#define HW_OPT_HAS_WIFI		(1 << 21)
+
+int read_booter_cfg(unsigned id, void *buf, int amount);
+
+#endif
--- a/arch/mips/include/asm/string.h
+++ b/arch/mips/include/asm/string.h
@@ -108,8 +108,9 @@ strncmp(__const__ char *__cs, __const__
 	__asm__ __volatile__(
 	".set\tnoreorder\n\t"
 	".set\tnoat\n"
-	"1:\tlbu\t%3,(%0)\n\t"
-	"beqz\t%2,2f\n\t"
+	"1:\tbeqz\t%2,2f\n\t"
+	"nop\n\t"
+	"lbu\t%3,(%0)\n\t"
 	"lbu\t$1,(%1)\n\t"
 	"subu\t%2,1\n\t"
 	"bne\t$1,%3,3f\n\t"
--- /dev/null
+++ b/arch/mips/include/asm/vm.h
@@ -0,0 +1,43 @@
+#ifndef MT_VM_H
+#define MT_VM_H
+
+#define VIRQ_BASE	64
+
+#define hypercall(name, nr, ...)		\
+	asm(					\
+		".global " #name ";"		\
+		".align 2;"			\
+		".set	push;"			\
+		".set	noreorder;"		\
+		".type " #name ",@function;"	\
+		".ent " #name ",0;"		\
+		#name ": .frame $sp,0,$ra;"	\
+		"li $3, " #nr ";"		\
+		"li $2, -22;"			\
+		"mtc0 $0, $1;"			\
+		"jr $ra;"			\
+		"nop;"				\
+		".end " #name ";"		\
+		".size " #name ",.-" #name ";"	\
+		".set	pop"			\
+        );					\
+	asmlinkage extern int name(__VA_ARGS__);
+
+/* NOTE: do not allow vdma_descr to span multiple pages, so align it */
+struct vdma_descr {
+	unsigned addr;
+	unsigned size;
+	unsigned next;
+} __attribute__((aligned(16)));
+
+#define DONE		0x80000000
+
+static inline unsigned get_virq_nr(unsigned hwirq)
+{
+	return VIRQ_BASE + hwirq;
+}
+
+extern int vm_running(void);
+#define hc_yield() asm volatile ("wait")
+
+#endif
--- a/arch/mips/kernel/Makefile
+++ b/arch/mips/kernel/Makefile
@@ -5,7 +5,7 @@
 extra-y		:= head.o vmlinux.lds
 
 obj-y		+= cpu-probe.o branch.o entry.o genex.o idle.o irq.o process.o \
-		   prom.o ptrace.o reset.o setup.o signal.o syscall.o \
+		   prom.o ptrace.o reset.o setup.o signal.o syscall.o backtrace.o \
 		   time.o topology.o traps.o unaligned.o watch.o vdso.o
 
 ifdef CONFIG_FUNCTION_TRACER
--- /dev/null
+++ b/arch/mips/kernel/backtrace.c
@@ -0,0 +1,156 @@
+#include <linux/module.h>
+#include <linux/oprofile.h>
+#include <linux/mm.h>
+#include <asm/page.h>
+#include <asm/processor.h>
+#include <asm/uaccess.h>
+
+#define INSTR_JR_RA	0x03e00008
+#define INSTR_JRHB_RA	0x03e00408
+#define INSTR_ADDIU_SP	0x241d0000
+#define INSTR_SW_RA_SP	0xafbf0000
+#define INSTR_MOVE_RA_ZERO	0x0000f821
+#define REGS_MASK	0x03e00000
+#define IMM16_MASK	0x0000ffff
+
+#define REG_SP		29
+#define TO_REGS(x)	((x) << 21)
+
+static inline int fetch_u32(void *val, void *ptr, int usermode)
+{
+	if (((unsigned) ptr & 3) != 0)
+		return -EFAULT;
+
+	if (usermode)
+		return get_user(*(unsigned *) val, (unsigned *) ptr);
+
+	if (KSEGX(ptr) == KSEG3)
+		return __get_user(*(unsigned *) val, (unsigned *) ptr);
+
+	if (KSEGX(ptr) != KSEG0 && KSEGX(ptr) != KSEG2)
+		return -EFAULT;
+
+	if ((unsigned long) ptr < PAGE_OFFSET)
+		return -EFAULT;
+	if ((unsigned long) ptr  > (unsigned long) high_memory)
+		return -EFAULT;
+
+	return __get_user(*(unsigned *) val, (unsigned *) ptr);
+}
+
+static inline int is_bcond(unsigned i)
+{
+    unsigned c = (i >> 26) & 7;
+    switch (i >> 29) {
+    case 0:
+	if (c == 1)
+	    return (i & (1 << 19)) == 0;
+	/* fall trough */
+    case 2:
+	return c >= 4;
+    }
+    return 0;
+}
+
+static inline unsigned *find_prev_branch(unsigned *instr, unsigned *limit,
+					 int usermode)
+{
+    unsigned i = 0;
+    unsigned *target = instr;
+
+    for (--instr; instr > limit; --instr) {
+	if (fetch_u32(&i, instr, usermode))
+	    return 0;
+
+	if (is_bcond(i)) {
+	    if (instr + 1 + (short) i == target) {
+		return instr;
+	    }
+	} else if ((i & ~(IMM16_MASK | REGS_MASK)) == INSTR_ADDIU_SP) {
+	    if ((i & REGS_MASK) != TO_REGS(REG_SP)) {
+		/* not simple sp adjustment, probably switching stack here */
+		return 0;
+	    }
+	    /* check if frame start has been hit */
+	    if ((short) (i & IMM16_MASK) < 0) {
+		return 0;
+	    }
+	}
+    }
+    return 0;
+}
+
+unsigned long find_prev_frame(unsigned long pc, unsigned long ra,
+			      unsigned long *sp, int usermode)
+{
+    int storedRA = -1;
+    int frameSize = 0;
+    unsigned *instr;
+    unsigned *limit = (unsigned *) (pc - 4096);
+    unsigned i = 0;
+    int imm;
+
+    if (!fetch_u32(&i, (unsigned *) pc, usermode)) {
+	if ((i & ~(IMM16_MASK | REGS_MASK)) == INSTR_ADDIU_SP
+	    && (short) (i & IMM16_MASK) < 0) {
+	    /* we are at the beging of function, reserving stack */
+	    return ra;
+	}
+    }
+
+    for (instr = (unsigned *) pc - 1; instr > limit; --instr) {
+	if (fetch_u32(&i, instr, usermode))
+	    break;
+
+	if (i == INSTR_JR_RA || i == INSTR_JRHB_RA) {
+	    /* found prev func end */
+	    break;
+	} else if ((i & ~IMM16_MASK) == INSTR_SW_RA_SP) {
+	    /* remember where previous RA was stored */
+	    storedRA = (short) (i & IMM16_MASK);
+	} else if ((i & ~(IMM16_MASK | REGS_MASK)) == INSTR_ADDIU_SP) {
+	    if ((i & REGS_MASK) != TO_REGS(REG_SP)) {
+		/* not simple sp adjustment, probably switching stack here */
+		return 0;
+	    }
+
+	    imm = (short) (i & IMM16_MASK);
+	    if (imm >= 0) {
+		/* found prev func end (poping back stack frame),
+		   or end of our own func in other of it's threads (chunks) */
+		if (storedRA != -1)
+		    break;
+
+		instr = find_prev_branch(instr + 1, limit, usermode);
+		if (instr == 0) {
+		    /* no branch to us was found,
+		       it means we are at the begining of the frame */
+		    break;
+		}
+	    } else {
+		frameSize = -imm;
+		break;
+	    }
+	} else if (i == INSTR_MOVE_RA_ZERO) {
+	    /* we have come to the end of the world,
+	       __start() func sets up RA wrongly */
+	    return 0;
+	}
+    }
+
+    if (frameSize > 0) {
+	/* if we hit addiu sp,-X first, we have stack frame */
+
+	if (storedRA != -1) {
+	    if (fetch_u32(&ra, (char *) *sp + storedRA, usermode))
+		return 0;
+	    if (ra == 0)
+		return 0;
+	}
+	*sp += frameSize;
+	return ra;
+    }
+    return ra;
+}
+
+EXPORT_SYMBOL(find_prev_frame);
--- a/arch/mips/kernel/cevt-r4k.c
+++ b/arch/mips/kernel/cevt-r4k.c
@@ -112,6 +112,14 @@ static int c0_compare_int_pending(void)
  * so wait up to worst case number of cycle counter ticks for timer interrupt
  * changes to propagate to the cause register.
  */
+#define back_to_back_c0_hazard() \
+	do { \
+		back_to_back_c0_hazard(); \
+		back_to_back_c0_hazard(); \
+		back_to_back_c0_hazard(); \
+		back_to_back_c0_hazard(); \
+	} while (0)
+
 #define COMPARE_INT_SEEN_TICKS 50
 
 int c0_compare_int_usable(void)
--- a/arch/mips/kernel/head.S
+++ b/arch/mips/kernel/head.S
@@ -146,7 +146,7 @@ EXPORT(__image_cmdline)
 	.fill	0x400
 #endif /* CONFIG_IMAGE_CMDLINE_HACK */
 
-	__REF
+	__HEAD
 
 NESTED(kernel_entry, 16, sp)			# kernel entry point
 
--- a/arch/mips/kernel/module.c
+++ b/arch/mips/kernel/module.c
@@ -182,7 +182,9 @@ static inline bool is_phys_addr(void *pt
 #ifdef CONFIG_64BIT
 	return (KSEGX((unsigned long)ptr) == CKSEG0);
 #else
-	return (KSEGX(ptr) == KSEG0);
+//	return (KSEGX(ptr) == KSEG0);
+	unsigned addr = (unsigned) ptr;
+	return addr && (addr < VMALLOC_START || addr > VMALLOC_END);
 #endif
 }
 
--- a/arch/mips/kernel/proc.c
+++ b/arch/mips/kernel/proc.c
@@ -14,12 +14,14 @@
 #include <asm/mipsregs.h>
 #include <asm/processor.h>
 #include <asm/prom.h>
+#include <asm/time.h>
 
 unsigned int vced_count, vcei_count;
 
 static int show_cpuinfo(struct seq_file *m, void *v)
 {
 	unsigned long n = (unsigned long) v - 1;
+	unsigned cpu_khz = mips_hpt_frequency / 500;
 	unsigned int version = cpu_data[n].processor_id;
 	unsigned int fp_vers = cpu_data[n].fpu_id;
 	char fmt [64];
@@ -46,6 +48,8 @@ static int show_cpuinfo(struct seq_file
 	seq_printf(m, fmt, __cpu_name[n],
 		      (version >> 4) & 0x0f, version & 0x0f,
 		      (fp_vers >> 4) & 0x0f, fp_vers & 0x0f);
+	seq_printf(m, "cpu MHz\t\t\t: %u.%03u\n",
+		      cpu_khz / 1000, (cpu_khz % 1000));
 	seq_printf(m, "BogoMIPS\t\t: %u.%02u\n",
 		      cpu_data[n].udelay_val / (500000/HZ),
 		      (cpu_data[n].udelay_val / (5000/HZ)) % 100);
--- a/arch/mips/kernel/time.c
+++ b/arch/mips/kernel/time.c
@@ -70,6 +70,7 @@ EXPORT_SYMBOL(perf_irq);
  */
 
 unsigned int mips_hpt_frequency;
+EXPORT_SYMBOL(mips_hpt_frequency);
 
 /*
  * This function exists in order to cause an error due to a duplicate
--- a/arch/mips/kernel/traps.c
+++ b/arch/mips/kernel/traps.c
@@ -91,6 +91,8 @@ void (*board_bind_eic_interrupt)(int irq
 void (*board_ebase_setup)(void);
 void __cpuinitdata(*board_cache_error_setup)(void);
 
+#define CONFIG_RAWBACKTRACE
+#ifdef CONFIG_RAWBACKTRACE
 static void show_raw_backtrace(unsigned long reg29)
 {
 	unsigned long *sp = (unsigned long *)(reg29 & ~3);
@@ -144,6 +146,25 @@ static void show_backtrace(struct task_s
 	printk("\n");
 }
 
+#else
+
+static void show_backtrace(struct task_struct *task, const struct pt_regs *regs)
+{
+	unsigned long sp = regs->regs[29];
+	unsigned long ra = regs->regs[31];
+	unsigned long pc = regs->cp0_epc;
+	int depth = 16;
+
+	printk("Call Trace:\n");
+	while (depth-- && pc) {
+	    print_ip_sym(pc);
+	    pc = find_prev_frame(pc, ra, &sp, 0);
+	    ra = 0;
+	}
+	printk("\n");
+}
+#endif
+
 /*
  * This routine abuses get_user()/put_user() to reference pointers
  * with at least a bit of error checking ...
@@ -367,6 +388,7 @@ void __noreturn die(const char *str, str
 	if (notify_die(DIE_OOPS, str, regs, 0, regs_to_trapnr(regs), SIGSEGV) == NOTIFY_STOP)
 		sig = 0;
 
+	oops_enter();
 	console_verbose();
 	raw_spin_lock_irq(&die_lock);
 #ifdef CONFIG_MIPS_MT_SMTC
@@ -1487,7 +1509,7 @@ void __init *set_except_vector(int n, vo
 #endif
 		u32 *buf = (u32 *)(ebase + 0x200);
 		unsigned int k0 = 26;
-		if ((handler & jump_mask) == ((ebase + 0x200) & jump_mask)) {
+		if ((handler & jump_mask) == ((KSEG0ADDR(ebase) + 0x200) & jump_mask)) {
 			uasm_i_j(&buf, handler & ~jump_mask);
 			uasm_i_nop(&buf);
 		} else {
@@ -1727,6 +1749,7 @@ void __cpuinit per_cpu_trap_init(bool is
 	 *  o read IntCtl.IPTI to determine the timer interrupt
 	 *  o read IntCtl.IPPCI to determine the performance counter interrupt
 	 */
+#ifdef CONFIG_CPU_MIPSR2
 	if (cpu_has_mips_r2) {
 		cp0_compare_irq_shift = CAUSEB_TI - CAUSEB_IP;
 		cp0_compare_irq = (read_c0_intctl() >> INTCTLB_IPTI) & 7;
@@ -1734,10 +1757,17 @@ void __cpuinit per_cpu_trap_init(bool is
 		if (cp0_perfcount_irq == cp0_compare_irq)
 			cp0_perfcount_irq = -1;
 	} else {
+#endif
 		cp0_compare_irq = CP0_LEGACY_COMPARE_IRQ;
 		cp0_compare_irq_shift = CP0_LEGACY_PERFCNT_IRQ;
 		cp0_perfcount_irq = -1;
+#ifdef CONFIG_CPU_MIPSR2
 	}
+#endif
+
+#ifdef CONFIG_MIPS_MIKROTIK
+       cp0_compare_irq = CP0_LEGACY_COMPARE_IRQ;
+#endif
 
 #ifdef CONFIG_MIPS_MT_SMTC
 	}
@@ -1833,7 +1863,7 @@ void __init trap_init(void)
 #define KVM_GUEST_KSEG0     0x40000000
         ebase = KVM_GUEST_KSEG0;
 #else
-        ebase = CKSEG0;
+        ebase = CAC_BASE;
 #endif
 		if (cpu_has_mips_r2)
 			ebase += (read_c0_ebase() & 0x3ffff000);
--- a/arch/mips/kernel/unaligned.c
+++ b/arch/mips/kernel/unaligned.c
@@ -106,6 +106,24 @@ static u32 unaligned_action;
 #endif
 extern void show_registers(struct pt_regs *regs);
 
+#define RATE_BURST (10*5*HZ)
+#define RATE_COST (5*HZ)
+
+static int un_ratelimit(void) {
+	static unsigned toks = RATE_BURST;
+	static unsigned last_msg;
+
+	unsigned now = jiffies;
+	toks += now - last_msg;
+	if (toks > RATE_BURST) toks = RATE_BURST;
+
+	if (toks >= RATE_COST) {
+		toks -= RATE_COST;
+		return 1;
+	}
+	return 0;
+}
+
 #ifdef __BIG_ENDIAN
 #define     LoadHW(addr, value, res)  \
 		__asm__ __volatile__ (".set\tnoat\n"        \
@@ -1549,10 +1567,24 @@ sigill:
 	    ("Unhandled kernel unaligned access or invalid instruction", regs);
 	force_sig(SIGILL, current);
 }
+
+extern asmlinkage void do_page_fault(struct pt_regs *regs, unsigned long write,
+				     unsigned long address);
+
 asmlinkage void do_ade(struct pt_regs *regs)
 {
 	unsigned int __user *pc;
 	mm_segment_t seg;
+	unsigned long badvaddr = regs->cp0_badvaddr;
+
+	/* We are running in VM protected enviroment and
+	   we hit KSEG0, or KSEG3 address */
+	if ((badvaddr & 3) == 0 && KSEGX(badvaddr) == KSEG3) {
+		do_page_fault(regs, (regs->cp0_cause & 0x7c) == 20,
+			      badvaddr);
+		return;
+	}
+
 
 	perf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS,
 			1, regs, regs->cp0_badvaddr);
@@ -1614,6 +1646,10 @@ asmlinkage void do_ade(struct pt_regs *r
 		show_registers(regs);
 	pc = (unsigned int __user *)exception_epc(regs);
 
+	if (!user_mode(regs) && un_ratelimit())
+		printk(KERN_WARNING "unaligned data access %lx at %p %pS\n",
+			badvaddr, pc, (void *)pc);
+
 	seg = get_fs();
 	if (!user_mode(regs))
 		set_fs(KERNEL_DS);
--- a/arch/mips/kernel/vmlinux.lds.S
+++ b/arch/mips/kernel/vmlinux.lds.S
@@ -51,6 +51,7 @@ SECTIONS
 	/* read-only */
 	_text = .;	/* Text and read-only data */
 	.text : {
+	        HEAD_TEXT
 		TEXT_TEXT
 		SCHED_TEXT
 		LOCK_TEXT
--- a/arch/mips/lib/iomap.c
+++ b/arch/mips/lib/iomap.c
@@ -25,6 +25,8 @@
 
 #define PIO_MASK	0x0ffffUL
 
+#ifndef CONFIG_MIPS_MIKROTIK
+
 unsigned int ioread8(void __iomem *addr)
 {
 	return readb(addr);
@@ -194,6 +196,8 @@ void iowrite32_rep(void __iomem *addr, c
 
 EXPORT_SYMBOL(iowrite32_rep);
 
+#endif
+
 /*
  * Create a virtual mapping cookie for an IO port range
  *
--- a/arch/mips/mm/c-r4k.c
+++ b/arch/mips/mm/c-r4k.c
@@ -1013,7 +1013,9 @@ static void __cpuinit probe_pcache(void)
 			      c->dcache.linesz;
 		c->dcache.waybit = __ffs(dcache_size/c->dcache.ways);
 
+#ifdef CONFIG_CPU_HAS_PREFETCH
 		c->options |= MIPS_CPU_PREFETCH;
+#endif
 		break;
 	}
 
--- a/arch/mips/mm/cache.c
+++ b/arch/mips/mm/cache.c
@@ -50,6 +50,7 @@ void (*flush_icache_all)(void);
 EXPORT_SYMBOL_GPL(local_flush_data_cache_page);
 EXPORT_SYMBOL(flush_data_cache_page);
 EXPORT_SYMBOL(flush_icache_all);
+EXPORT_SYMBOL(flush_icache_range);
 
 #ifdef CONFIG_DMA_NONCOHERENT
 
--- a/arch/mips/mm/dma-default.c
+++ b/arch/mips/mm/dma-default.c
@@ -14,6 +14,10 @@
 #include <linux/module.h>
 #include <linux/scatterlist.h>
 #include <linux/string.h>
+#ifdef CONFIG_MAPPED_KERNEL
+#include <linux/hardirq.h>
+#include <linux/sched.h>
+#endif
 #include <linux/gfp.h>
 #include <linux/highmem.h>
 
@@ -68,11 +72,9 @@ static gfp_t massage_gfp_flags(const str
 	/* ignore region specifiers */
 	gfp &= ~(__GFP_DMA | __GFP_DMA32 | __GFP_HIGHMEM);
 
-#ifdef CONFIG_ISA
 	if (dev == NULL)
 		dma_flag = __GFP_DMA;
 	else
-#endif
 #if defined(CONFIG_ZONE_DMA32) && defined(CONFIG_ZONE_DMA)
 	     if (dev->coherent_dma_mask < DMA_BIT_MASK(32))
 			dma_flag = __GFP_DMA;
@@ -135,8 +137,15 @@ void *mips_dma_alloc_coherent(struct dev
 
 		if (!plat_device_is_coherent(dev)) {
 			dma_cache_wback_inv((unsigned long) ret, size);
+#ifndef CONFIG_MAPPED_KERNEL
 			if (!hw_coherentio)
 				ret = UNCAC_ADDR(ret);
+#else
+			if (!in_interrupt())
+				ret = ioremap((unsigned long) *dma_handle, size);
+			else
+				ret = UNCAC_ADDR(ret);
+#endif
 		}
 	}
 
@@ -162,10 +171,24 @@ void mips_dma_free_coherent(struct devic
 	if (dma_release_from_coherent(dev, order, vaddr))
 		return;
 
+#ifndef CONFIG_MAPPED_KERNEL
 	plat_unmap_dma_mem(dev, dma_handle, size, DMA_BIDIRECTIONAL);
 
 	if (!plat_device_is_coherent(dev) && !hw_coherentio)
 		addr = CAC_ADDR(addr);
+#else
+	if (!plat_device_is_coherent(dev)) {
+		pgd_t *pgd = init_mm.pgd + __pgd_offset(addr);
+		pud_t *pud = pud_offset(pgd, addr);
+		pmd_t *pmd = pmd_offset(pud, addr);
+		pte_t *pte = pte_offset(pmd, addr);
+
+		if (pte_present(*pte)) {
+			addr = (unsigned long) pfn_to_kaddr(pte_pfn(*pte));
+			iounmap(vaddr);
+		}
+	}
+#endif
 
 	free_pages(addr, get_order(size));
 }
--- a/arch/mips/mm/fault.c
+++ b/arch/mips/mm/fault.c
@@ -85,6 +85,12 @@ asmlinkage void __kprobes do_page_fault(
 		goto VMALLOC_FAULT_TARGET;
 #endif
 
+#ifdef CONFIG_MAPPED_KERNEL
+	/* in case we touched other VM memory */
+	if (KSEGX(address) == KSEG2)
+		goto VMALLOC_FAULT_TARGET;
+#endif
+
 	/*
 	 * If we're in an interrupt or have no user
 	 * context, we must not take the fault..
--- a/arch/mips/mm/init.c
+++ b/arch/mips/mm/init.c
@@ -44,6 +44,10 @@
 #include <asm/tlb.h>
 #include <asm/fixmap.h>
 
+#ifdef CONFIG_MIPS_MIKROTIK
+#include <asm/rb/boards.h>
+#endif
+
 /* Atomicity and interruptability */
 #ifdef CONFIG_MIPS_MT_SMTC
 
@@ -173,7 +177,7 @@ void *kmap_coherent(struct page *page, u
 
 #define UNIQUE_ENTRYHI(idx) (CKSEG0 + ((idx) << (PAGE_SHIFT + 1)))
 
-void kunmap_coherent(void)
+void kunmap_coherent()
 {
 #ifndef CONFIG_MIPS_MT_SMTC
 	unsigned int wired;
@@ -333,6 +337,10 @@ void __init paging_init(void)
 
 #ifdef CONFIG_ZONE_DMA
 	max_zone_pfns[ZONE_DMA] = MAX_DMA_PFN;
+#if defined(CONFIG_MIPS_MIKROTIK)
+	if (mips_machgroup != MACH_GROUP_MT_RB100)
+		max_zone_pfns[ZONE_DMA] = max_low_pfn;
+#endif
 #endif
 #ifdef CONFIG_ZONE_DMA32
 	max_zone_pfns[ZONE_DMA32] = MAX_DMA32_PFN;
--- a/arch/mips/mm/ioremap.c
+++ b/arch/mips/mm/ioremap.c
@@ -127,6 +127,7 @@ void __iomem * __ioremap(phys_t phys_add
 	if (!size || last_addr < phys_addr)
 		return NULL;
 
+#ifndef CONFIG_MAPPED_KERNEL
 	/*
 	 * Map uncached objects in the low 512mb of address space using KSEG1,
 	 * otherwise map using page tables.
@@ -149,6 +150,7 @@ void __iomem * __ioremap(phys_t phys_add
 			if(!PageReserved(page))
 				return NULL;
 	}
+#endif
 
 	/*
 	 * Mappings have to be page-aligned
--- a/arch/mips/mm/tlb-r4k.c
+++ b/arch/mips/mm/tlb-r4k.c
@@ -408,7 +408,9 @@ void __cpuinit tlb_init(void)
 	 *     be set to fixed-size pages.
 	 */
 	write_c0_pagemask(PM_DEFAULT_MASK);
+#ifndef CONFIG_MAPPED_KERNEL
 	write_c0_wired(0);
+#endif
 	if (current_cpu_type() == CPU_R10000 ||
 	    current_cpu_type() == CPU_R12000 ||
 	    current_cpu_type() == CPU_R14000)
--- a/arch/mips/oprofile/Makefile
+++ b/arch/mips/oprofile/Makefile
@@ -4,6 +4,7 @@ DRIVER_OBJS = $(addprefix ../../../drive
 		oprof.o cpu_buffer.o buffer_sync.o \
 		event_buffer.o oprofile_files.o \
 		oprofilefs.o oprofile_stats.o \
+		hrtimer.o \
 		timer_int.o )
 
 oprofile-y				:= $(DRIVER_OBJS) common.o backtrace.o
--- a/arch/mips/oprofile/common.c
+++ b/arch/mips/oprofile/common.c
@@ -11,10 +11,14 @@
 #include <linux/init.h>
 #include <linux/oprofile.h>
 #include <linux/smp.h>
+#include <asm/ptrace.h>
 #include <asm/cpu-info.h>
+#include <asm/rb/boards.h>
 
 #include "op_impl.h"
 
+extern int __init hrtimer_oprofile_init(struct oprofile_operations *);
+
 extern struct op_mips_model op_model_mipsxx_ops __weak;
 extern struct op_mips_model op_model_loongson2_ops __weak;
 
@@ -70,11 +74,30 @@ static void op_mips_stop(void)
 	on_each_cpu(model->cpu_stop, NULL, 1);
 }
 
+void mt_op_mips_backtrace(struct pt_regs * const regs, unsigned int depth)
+{
+	unsigned long ra = regs->regs[31];
+	unsigned long pc = regs->cp0_epc;
+	unsigned long sp = regs->regs[29];
+	int usermode = user_mode(regs);
+
+	while (depth-- && pc) {
+	    pc = find_prev_frame(pc, ra, &sp, usermode);
+	    if (pc) oprofile_add_trace((unsigned long) pc);
+	    ra = 0;
+	}
+}
+
 int __init oprofile_arch_init(struct oprofile_operations *ops)
 {
 	struct op_mips_model *lmodel = NULL;
 	int res;
 
+	ops->backtrace = mt_op_mips_backtrace;
+
+	if (hrtimer_oprofile_init(ops) == 0)
+		return 0;
+
 	switch (current_cpu_type()) {
 	case CPU_5KC:
 	case CPU_M14KC:
--- /dev/null
+++ b/arch/mips/rb/Makefile
@@ -0,0 +1 @@
+obj-y += prom.o platform.o irq.o iomap.o
--- /dev/null
+++ b/arch/mips/rb/Platform
@@ -0,0 +1,17 @@
+#
+# Mikrotik RB100/RB500 boards
+#
+platform-$(CONFIG_MIPS_MIKROTIK) += rb/
+platform-$(CONFIG_MIPS_MIKROTIK) += rb/rb500/
+platform-$(CONFIG_MIPS_MIKROTIK) += rb/rb100/
+platform-$(CONFIG_MIPS_MIKROTIK) += rb/rb400/
+platform-$(CONFIG_MIPS_MIKROTIK) += rb/cr/
+platform-$(CONFIG_MIPS_MIKROTIK) += rb/vm/
+cflags-$(CONFIG_MIPS_MIKROTIK) += -I$(srctree)/arch/mips/include/asm/mach-rb
+ifdef CONFIG_MAPPED_KERNEL
+load-$(CONFIG_MIPS_MIKROTIK) += 0xffffffffc0101000
+OBJCOPYFLAGS += --change-addresses=0xc0000000
+else
+load-$(CONFIG_MIPS_MIKROTIK) += 0xffffffff80101000
+endif
+
--- /dev/null
+++ b/arch/mips/rb/irq.c
@@ -0,0 +1,126 @@
+#include <linux/init.h>
+#include <linux/linkage.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/bitops.h>
+#include <linux/module.h>
+#include <asm/signal.h>
+#include <asm/mipsregs.h>
+#include <asm/irq_cpu.h>
+#include <asm/bootinfo.h>
+#include <asm/vm.h>
+#include <asm/rb/boards.h>
+
+extern void rb500_init_irq(void);
+extern void rb100_init_irq(void);
+extern void rb400_init_irq(void);
+extern void cr_init_irq(void);
+
+asmlinkage void plat_irq_dispatch(void) {
+	unsigned pending = read_c0_status() & read_c0_cause() & 0xfe00;
+
+	if (pending)
+		do_IRQ(fls(pending) - (9 - MIPS_CPU_IRQ_BASE));
+}
+
+volatile unsigned long virqs;
+EXPORT_SYMBOL(virqs);
+
+static void ack_virq(struct irq_data *d)
+{
+	clear_bit(d->irq - VIRQ_BASE, &virqs);
+}
+
+static inline void unmask_virq(struct irq_data *d)
+{
+}
+
+static inline void mask_virq(struct irq_data *d)
+{
+}
+
+static struct irq_chip virq_controller = {
+	.name	= "virq",
+	.irq_ack	= ack_virq,
+	.irq_unmask     = unmask_virq,
+	.irq_mask	= mask_virq,
+};
+
+static irqreturn_t virq_cascade_irq(int irq, void *dev_id)
+{
+	unsigned i;
+	unsigned irqs = virqs;
+
+	for (i = 0; irqs; ++i) {
+		if (irqs & (1 << i)) {
+			do_IRQ(i + VIRQ_BASE);
+			irqs ^= (1 << i);
+		}
+	}
+	return IRQ_HANDLED;
+}
+
+static struct irqaction virq_cascade  = {
+	.handler = virq_cascade_irq,
+	.name = "virq-cascade",
+};
+
+static void soft_irq_ack(struct irq_data *d)
+{
+	clear_c0_cause(0x100 << (d->irq - MIPS_CPU_IRQ_BASE));
+}
+
+static inline void unmask_soft_irq(struct irq_data *d)
+ {
+	set_c0_status(0x100 << (d->irq - MIPS_CPU_IRQ_BASE));
+	irq_enable_hazard();
+ }
+ 
+static inline void mask_soft_irq(struct irq_data *d)
+{
+	clear_c0_status(0x100 << (d->irq - MIPS_CPU_IRQ_BASE));
+	irq_disable_hazard();
+}
+
+static struct irq_chip soft_irq_controller = {
+	.name	= "MIPS",
+	.irq_ack	= soft_irq_ack,
+	.irq_unmask     = unmask_soft_irq,
+	.irq_mask	= mask_soft_irq,
+};
+
+extern void ont_arch_init_irq(void);
+
+void __init arch_init_irq(void)
+{
+	unsigned i;
+
+	switch (mips_machgroup) {
+	case MACH_GROUP_MT_RB500:
+		rb500_init_irq();
+		break;
+	case MACH_GROUP_MT_RB100:
+		rb100_init_irq();
+		break;
+	case MACH_GROUP_MT_RB400:
+	case MACH_GROUP_MT_RB700:
+		rb400_init_irq();
+		break;
+	case MACH_GROUP_MT_CR:
+		cr_init_irq();
+		break;
+	case MACH_GROUP_MT_VM:
+		mips_cpu_irq_init();
+		break;
+	}
+
+	if (mips_machgroup != MACH_GROUP_MT_RB500 &&
+	    mips_machgroup != MACH_GROUP_MT_RB100) {
+		irq_set_chip_and_handler(1, &soft_irq_controller, handle_percpu_irq);
+		setup_irq(1, &virq_cascade);
+		
+		for (i = VIRQ_BASE;  i < VIRQ_BASE + 32; ++i)
+			irq_set_chip_and_handler(i, &virq_controller,
+						 handle_edge_irq);
+	}
+}
--- /dev/null
+++ b/arch/mips/rb/platform.c
@@ -0,0 +1,1780 @@
+#include <linux/platform_device.h>
+#include <linux/serial.h>
+#include <linux/serial_8250.h>
+#include <linux/spi/spi.h>
+#include <linux/mtd/partitions.h>
+#include <linux/spi/flash.h>
+#include <linux/i2c-gpio.h>
+#include <asm/bootinfo.h>
+#include <asm/rb/boards.h>
+#include <asm/rb/rb400.h>
+#include <asm/rb/booter.h>
+#include <asm/serial.h>
+
+struct hwopt_device {
+	struct platform_device *plat;
+	unsigned val;
+	unsigned mask;
+};
+
+static int platform_add_hwopt_devices(struct hwopt_device *devs, int cnt) {
+	int i;
+	unsigned hw_opt = 0;
+	read_booter_cfg(ID_HW_OPTIONS, &hw_opt, 4);
+	printk("hw_options %x\n", hw_opt);
+
+	for (i = 0; i < cnt; ++i) {
+		struct hwopt_device *dev = &devs[i];
+		if ((hw_opt & (dev->val | dev->mask)) == dev->val) {
+			printk("adding platform device %s\n", dev->plat->name);
+			platform_device_register(dev->plat);
+		}
+	}
+	return 0;
+}
+
+static struct platform_device rb100_uart_device = {
+	.name	= "rb100-uart",
+	.id	= -1,
+};
+
+static struct platform_device rb500_nand_device = {
+	.name	= "rb500-nand",
+	.id	= -1,
+};
+
+static struct platform_device rb500r5_nand_device = {
+	.name	= "rb500r5-nand",
+	.id	= -1,
+};
+
+static struct platform_device rb700_nand_device = {
+	.name	= "rb700-nand",
+	.id	= -1,
+	.dev	= {
+		.platform_data = (void *)0,
+	},
+};
+
+static struct platform_device rb700_nolatch_nand_device = {
+	.name	= "rb700-nand",
+	.id	= -1,
+	.dev	= {
+		.platform_data = (void *)1,
+	},
+};
+
+static struct platform_device rb700_tiny_nand_device = {
+	.name	= "rb700-nand",
+	.id	= -1,
+	.dev	= {
+		.platform_data = (void *)2,
+	},
+};
+
+static struct platform_device rb750g_nand_device = {
+	.name	= "rb750g-nand",
+	.id	= -1,
+};
+
+static struct platform_device rb100_nand_device = {
+	.name	= "rb100-nand",
+	.id	= -1,
+};
+
+static struct platform_device cr_nand_device = {
+	.name	= "cr-nand",
+	.id	= -1,
+};
+
+static struct platform_device mr_nand_device = {
+	.name	= "mr-nand",
+	.id	= -1,
+};
+
+static struct platform_device ar9342_nand_device = {
+	.name	= "ar9342-nand",
+	.id	= -1,
+};
+
+static struct platform_device ar9344_nand_device = {
+	.name	= "ar9344-nand",
+	.id	= -1,
+};
+
+static struct rb400_ssr_info rb400_ssr_data = {
+	GPO_SSR_STRB, 1,
+	SSR_BIT_nLED1 | SSR_BIT_nLED2 |
+	SSR_BIT_nLED3 | SSR_BIT_nLED4 |
+	SSR_BIT_nLED5 |
+	SSR_BIT_FAN_ON | SSR_BIT_USB_EN
+};
+static struct spi_board_info rb400_spi_misc = {
+	.modalias = "rb400-spi-misc",
+	.max_speed_hz = 10 * 1000 * 1000,
+	.bus_num = 0,
+	.chip_select = 0,
+	.mode = SPI_MODE_0,
+	.platform_data = &rb400_ssr_data,
+};
+
+static struct spi_board_info rb400_spi_nand = {
+	.modalias = "rb400-spi-nand",
+	.max_speed_hz = 33 * 1000 * 1000,
+	.bus_num = 0,
+	.chip_select = 1,
+	.mode = SPI_MODE_0,
+};
+static struct spi_board_info rb400_spi_microsd = {
+	.modalias = "mmc_spi",
+	.max_speed_hz = 10 * 1000 * 1000,
+	.bus_num = 0,
+	.chip_select = 2,
+	.mode = SPI_MODE_0,
+};
+static struct spi_board_info rb700_spi_attiny = {
+	.modalias = "rb700-spi-attiny",
+	.max_speed_hz = 1 * 1000 * 1000,
+	.bus_num = 0,
+	.chip_select = 3,
+	.mode = SPI_MODE_0,
+};
+static struct spi_board_info rb700_spi_nand = {
+	.modalias = "rb700-spi-nand",
+	.max_speed_hz = 0,
+	.bus_num = 0,
+	.chip_select = 1,
+	.mode = SPI_CS_HIGH,
+};
+
+static struct spi_board_info *rb400_spi_info[] = {
+	&rb400_spi_misc,
+	&rb400_spi_nand,
+	NULL
+};
+
+static struct spi_board_info *rb433_spi_info[] = {
+	&rb400_spi_misc,
+	&rb400_spi_nand,
+	&rb400_spi_microsd,
+	NULL
+};
+
+static struct spi_board_info *rb750_spi_info[] = {
+	&rb400_spi_misc,
+	NULL
+};
+
+static struct spi_board_info *rb711_spi_info[] = {
+	&rb400_spi_misc,
+	&rb700_spi_nand,
+	NULL
+};
+
+static struct spi_board_info *omni_spi_info[] = {
+	&rb400_spi_misc,
+	&rb700_spi_attiny,
+	&rb700_spi_nand,
+	NULL
+};
+
+static struct platform_device omni_spi_device = {
+	.name	= "rb400-spi",
+	.id	= -1,
+	.dev	= {
+		.platform_data = omni_spi_info,
+	},
+};
+
+static struct platform_device rb400_spi_device = {
+	.name	= "rb400-spi",
+	.id	= -1,
+	.dev	= {
+		.platform_data = rb400_spi_info,
+	},
+};
+
+static struct platform_device rb433_spi_device = {
+	.name	= "rb400-spi",
+	.id	= -1,
+	.dev	= {
+		.platform_data = rb433_spi_info,
+	},
+};
+
+static struct platform_device rb750_spi_device = {
+	.name	= "rb400-spi",
+	.id	= -1,
+	.dev	= {
+		.platform_data = rb750_spi_info,
+	},
+};
+
+static struct platform_device rb711_spi_device = {
+	.name	= "rb400-spi",
+	.id	= -1,
+	.dev	= {
+		.platform_data = rb711_spi_info,
+	},
+};
+
+static struct rb400_ssr_info rb900_ssr_data = { (1 << 17), 2, 0x0c00 };
+static struct spi_board_info rb900_spi_misc = {
+	.modalias = "rb400-spi-misc",
+	.max_speed_hz = 33333334,
+	.bus_num = 0,
+	.chip_select = 0,
+	.mode = SPI_MODE_0,
+	.platform_data = &rb900_ssr_data,
+};
+
+static struct spi_board_info rb2011_spi_lcd = {
+	.modalias = "rb2011-spi-lcd",
+	.max_speed_hz = 15 * 1000 * 1000,
+	.bus_num = 0,
+	.chip_select = 1,
+	.mode = SPI_MODE_0,
+};
+
+static struct spi_board_info rb2011_spi_ts = {
+	.modalias = "rb2011-spi-ts",
+	.max_speed_hz = 2500 * 1000,
+	.bus_num = 0,
+	.chip_select = 2,
+	.mode = SPI_MODE_0,
+};
+
+static struct spi_board_info *rb2011_spi_info[] = {
+	&rb900_spi_misc,
+	&rb2011_spi_lcd,
+	&rb2011_spi_ts,
+	NULL
+};
+
+static struct platform_device rb2011_spi_device = {
+	.name	= "rb900-spi",
+	.id	= -1,
+	.dev	= {
+		.platform_data = rb2011_spi_info,
+	},
+};
+
+static struct spi_board_info *rb2011L_spi_info[] = {
+	&rb900_spi_misc,
+	NULL
+};
+
+static struct platform_device rb2011L_spi_device = {
+	.name	= "rb900-spi",
+	.id	= -1,
+	.dev	= {
+		.platform_data = rb2011L_spi_info,
+	},
+};
+
+static struct platform_device flash_nor_device = {
+	.name	= "flash-nor",
+	.id	= -1,
+};
+
+static struct platform_device flash_spi_device = {
+	.name	= "flash-spi",
+	.id	= -1,
+};
+
+static struct platform_device korina_device = {
+	.name	= "korina",
+	.id	= -1,
+};
+
+static struct platform_device rb100_led_device = {
+	.name	= "rb100-led",
+	.id	= -1,
+};
+
+static struct platform_device rb112_led_device = {
+	.name	= "rb112-led",
+	.id	= -1,
+};
+
+static struct rb400_leds rb400_led_map = {
+	.user_led	= PLD(4, PLED_TYPE_GPIO),
+	.led1		= PLD(0, PLED_TYPE_SHARED_RB400),
+	.led2		= PLD(1, PLED_TYPE_SHARED_RB400),
+	.led3		= PLD(2, PLED_TYPE_SHARED_RB400),
+	.led4		= PLD(3, PLED_TYPE_SHARED_RB400),
+	.led5		= PLD(8, PLED_TYPE_SHARED_RB400),
+};
+static struct platform_device rb400_led_device = {
+	.name	= "rb400-led",
+	.id	= -1,
+	.dev	= {
+		.platform_data = &rb400_led_map,
+	},
+};
+
+static struct rb400_leds rb411l_led_map = {
+	.user_led	= PLD(4, PLED_TYPE_GPIO),
+	.led1		= PLDI(4, PLED_TYPE_SSR_RB400),
+	.led2		= PLDI(3, PLED_TYPE_SSR_RB400),
+	.led3		= PLDI(2, PLED_TYPE_SSR_RB400),
+	.led4		= PLDI(1, PLED_TYPE_SSR_RB400),
+	.led5		= PLDI(0, PLED_TYPE_SSR_RB400),
+	.usb_power_off	= PLDI(7, PLED_TYPE_SSR_RB400),
+};
+static struct platform_device rb411l_led_device = {
+	.name	= "rb400-led",
+	.id	= -1,
+	.dev	= {
+		.platform_data = &rb411l_led_map,
+	},
+};
+
+static struct rb400_leds rb450g_led_map = {
+	.user_led	= PLD(4, PLED_TYPE_GPIO),
+	.led1		= PLD(8, PLED_TYPE_SHARED_RB400),
+};
+static struct platform_device rb450g_led_device = {
+	.name	= "rb400-led",
+	.id	= -1,
+	.dev	= {
+		.platform_data = &rb450g_led_map,
+	},
+};
+
+static struct rb400_leds rb493g_led_map = {
+	.user_led	= PLD(4, PLED_TYPE_GPIO),
+	.led1		= PLD(0, PLED_TYPE_SHARED_RB400),
+	.led2		= PLD(2, PLED_TYPE_SHARED_RB400),
+	.led3		= PLD(1, PLED_TYPE_SHARED_RB400),
+	.led4		= PLD(3, PLED_TYPE_SHARED_RB400),
+	.led5		= PLD(8, PLED_TYPE_SHARED_RB400),
+};
+static struct platform_device rb493g_led_device = {
+	.name	= "rb400-led",
+	.id	= -1,
+	.dev	= {
+		.platform_data = &rb493g_led_map,
+	},
+};
+
+static struct rb400_leds rb700_led_map = {
+	.user_led	= PLD(12, PLED_TYPE_SHARED_RB700),
+};
+static struct platform_device rb700_led_device = {
+	.name	= "rb400-led",
+	.id	= -1,
+	.dev	= {
+		.platform_data = &rb700_led_map,
+	},
+};
+
+static struct rb400_leds rb751_led_map = {
+	.user_led	= PLD(12, PLED_TYPE_SHARED_RB700),
+	.wlan_led	= PLDI(9, PLED_TYPE_WIFI),
+};
+static struct platform_device rb751_led_device = {
+	.name	= "rb400-led",
+	.id	= -1,
+	.dev	= {
+		.platform_data = &rb751_led_map,
+	},
+};
+
+static struct rb400_leds sxt5d_led_map = {
+	.user_led	= PLD(12, PLED_TYPE_SHARED_RB700),
+	.led1		= PLD(5, PLED_TYPE_WIFI),
+	.led2		= PLD(6, PLED_TYPE_WIFI),
+	.led3		= PLD(7, PLED_TYPE_WIFI),
+	.led4		= PLD(8, PLED_TYPE_WIFI),
+	.led5		= PLD(9, PLED_TYPE_WIFI),
+	.usb_power_off	= PLD(3, PLED_TYPE_WIFI),
+};
+static struct platform_device sxt5d_led_device = {
+	.name	= "rb400-led",
+	.id	= -1,
+	.dev	= {
+		.platform_data = &sxt5d_led_map,
+	},
+};
+
+static struct rb400_leds groove_led_map = {
+	.user_led	= PLD(12, PLED_TYPE_SHARED_RB700),
+	.led1		= PLD(9, PLED_TYPE_WIFI),
+	.led2		= PLD(8, PLED_TYPE_WIFI),
+	.led3		= PLD(7, PLED_TYPE_WIFI),
+	.led4		= PLD(6, PLED_TYPE_WIFI),
+	.led5		= PLD(5, PLED_TYPE_WIFI),
+	.usb_power_off	= PLD(3, PLED_TYPE_WIFI),
+};
+static struct platform_device groove_led_device = {
+	.name	= "rb400-led",
+	.id	= -1,
+	.dev	= {
+		.platform_data = &groove_led_map,
+	},
+};
+
+static struct rb400_leds rb711_led_map = {
+	.user_led	= PLD(1, PLED_TYPE_SHARED_RB700),
+	.led1		= PLD(12, PLED_TYPE_SHARED_RB700),
+	.led2		= PLD(13, PLED_TYPE_SHARED_RB700),
+	.led3		= PLD(14, PLED_TYPE_SHARED_RB700),
+	.led4		= PLD(15, PLED_TYPE_SHARED_RB700),
+	.led5		= PLD(16, PLED_TYPE_SHARED_RB700),
+};
+static struct platform_device rb711_led_device = {
+	.name	= "rb400-led",
+	.id	= -1,
+	.dev	= {
+		.platform_data = &rb711_led_map,
+	},
+};
+
+static struct rb400_leds rb711r3_led_map = {
+	.user_led	= PLD(1, PLED_TYPE_SHARED_RB700),
+	.led1		= PLD(12, PLED_TYPE_SHARED_RB700),
+	.led2		= PLD(14, PLED_TYPE_SHARED_RB700),
+	.led3		= PLD(15, PLED_TYPE_SHARED_RB700),
+	.led4		= PLD(16, PLED_TYPE_SHARED_RB700),
+	.usb_power_off	= PLD(4, PLED_TYPE_WIFI),
+};
+static struct platform_device rb711r3_led_device = {
+	.name	= "rb400-led",
+	.id	= -1,
+	.dev	= {
+		.platform_data = &rb711r3_led_map,
+	},
+};
+
+static struct rb400_leds rb711g_led_map = {
+	.user_led	= PLD(1, PLED_TYPE_SHARED_RB700),
+	.led1		= PLD(12, PLED_TYPE_SHARED_RB700),
+	.led2		= PLD(14, PLED_TYPE_SHARED_RB700),
+	.led3		= PLD(15, PLED_TYPE_SHARED_RB700),
+	.led4		= PLD(16, PLED_TYPE_SHARED_RB700),
+	.usb_power_off	= PLD(13, PLED_TYPE_SHARED_RB700),
+};
+static struct platform_device rb711g_led_device = {
+	.name	= "rb400-led",
+	.id	= -1,
+	.dev	= {
+		.platform_data = &rb711g_led_map,
+	},
+};
+
+static struct rb400_leds rb951g_led_map = {
+	.user_led	= PLD(4, PLED_TYPE_WIFI),
+	.usb_power_off	= PLDI(20, PLED_TYPE_GPIO),
+	.wlan_led	= PLD(0, PLED_TYPE_WIFI),
+	.button		= PLDI(15, PLED_TYPE_GPIO),
+};
+static struct platform_device rb951g_led_device = {
+	.name	= "rb400-led",
+	.id	= -1,
+	.dev	= {
+		.platform_data = &rb951g_led_map,
+	},
+};
+
+static struct rb400_leds rb2011l_led_map = {
+	.user_led	= PLD(4, PLED_TYPE_WIFI),
+	.button		= PLDI(15, PLED_TYPE_GPIO),
+};
+static struct platform_device rb2011L_led_device = {
+	.name	= "rb400-led",
+	.id	= -1,
+	.dev	= {
+		.platform_data = &rb2011l_led_map,
+	},
+};
+
+static struct rb400_leds rb2011_led_map = {
+#ifdef RB2011_USER_LED_ALWAYS
+	.user_led	= PLD(4, PLED_TYPE_WIFI),
+#endif
+	.usb_power_off	= PLDI(20, PLED_TYPE_GPIO_OE),
+	.lcd		= PLED(2, PLED_TYPE_GPIO, PLED_CFG_KEEP),
+	.button		= PLDI(15, PLED_TYPE_GPIO),
+};
+static struct platform_device rb2011_led_device = {
+	.name	= "rb400-led",
+	.id	= -1,
+	.dev	= {
+		.platform_data = &rb2011_led_map,
+	},
+};
+
+static struct rb400_leds crs125_led_map = {
+	.led2		= PLDI(11, PLED_TYPE_GPIO),
+	.usb_power_off	= PLDI(20, PLED_TYPE_GPIO_OE),
+	.button		= PLDI(15, PLED_TYPE_GPIO),
+	.lcd		= PLED(2, PLED_TYPE_GPIO, PLED_CFG_KEEP),
+};
+static struct platform_device crs125_led_device = {
+	.name	= "rb400-led",
+	.id	= -1,
+	.dev	= {
+		.platform_data = &crs125_led_map,
+	},
+};
+
+static struct rb400_leds rb2011r5_led_map = {
+#ifdef RB2011_USER_LED_ALWAYS
+	.user_led	= PLD(4, PLED_TYPE_WIFI),
+#endif
+	.usb_power_off	= PLDI(20, PLED_TYPE_GPIO_OE),
+	.lcd		= PLDI(0, PLED_TYPE_WIFI),
+	.button		= PLDI(15, PLED_TYPE_GPIO),
+};
+static struct platform_device rb2011r5_led_device = {
+	.name	= "rb400-led",
+	.id	= -1,
+	.dev	= {
+		.platform_data = &rb2011r5_led_map,
+	},
+};
+
+static struct rb400_leds rb2011r5_user_led_map = {
+	.user_led	= PLD(4, PLED_TYPE_WIFI),
+	.usb_power_off	= PLDI(20, PLED_TYPE_GPIO_OE),
+	.lcd		= PLDI(0, PLED_TYPE_WIFI),
+	.button		= PLDI(15, PLED_TYPE_GPIO),
+};
+static struct platform_device rb2011r5_user_led_device = {
+	.name	= "rb400-led",
+	.id	= -1,
+	.dev	= {
+		.platform_data = &rb2011r5_user_led_map,
+	},
+};
+
+static struct rb400_leds sxtg_led_map = {
+	.user_led	= PLD(12, PLED_TYPE_SHARED_RB700),
+	.led1		= PLD(5, PLED_TYPE_WIFI),
+	.led2		= PLD(6, PLED_TYPE_WIFI),
+	.led3		= PLD(7, PLED_TYPE_WIFI),
+	.led4		= PLD(8, PLED_TYPE_WIFI),
+	.led5		= PLD(9, PLED_TYPE_WIFI),
+	.usb_power_off	= PLD(3, PLED_TYPE_WIFI),
+	.power_led	= PLD(1, PLED_TYPE_WIFI),
+};
+static struct platform_device sxtg_led_device = {
+	.name	= "rb400-led",
+	.id	= -1,
+	.dev	= {
+		.platform_data = &sxtg_led_map,
+	},
+};
+
+static struct rb400_leds rb750g_led_map = {
+	.user_led	= PLD(4, PLED_TYPE_GPIO),
+};
+static struct platform_device rb750g_led_device = {
+	.name	= "rb400-led",
+	.id	= -1,
+	.dev	= {
+		.platform_data = &rb750g_led_map,
+	},
+};
+
+static struct rb400_leds rb750gl_led_map = {
+	.user_led	= PLD(12, PLED_TYPE_SHARED_RB700),
+	.usb_power_off	= PLD(13, PLED_TYPE_SHARED_RB700),
+};
+static struct platform_device rb750gl_led_device = {
+	.name	= "rb400-led",
+	.id	= -1,
+	.dev	= {
+		.platform_data = &rb750gl_led_map,
+	},
+};
+
+static struct rb400_leds rb751g_led_map = {
+	.user_led	= PLD(12, PLED_TYPE_SHARED_RB700),
+	.usb_power_off	= PLD(13, PLED_TYPE_SHARED_RB700),
+	.wlan_led	= PLDI(9, PLED_TYPE_WIFI),
+};
+static struct platform_device rb751g_led_device = {
+	.name	= "rb400-led",
+	.id	= -1,
+	.dev	= {
+		.platform_data = &rb751g_led_map,
+	},
+};
+
+static struct rb400_leds rb912g_led_map = {
+	.user_led	= PLD(2, PLED_TYPE_SHARED_RB900),
+	.led1		= PLD(0, PLED_TYPE_SSR_RB900),
+	.led2		= PLD(1, PLED_TYPE_SSR_RB900),
+	.led3		= PLD(2, PLED_TYPE_SSR_RB900),
+	.led4		= PLD(3, PLED_TYPE_SSR_RB900),
+	.led5		= PLD(4, PLED_TYPE_SSR_RB900),
+	.usb_power_off	= PLDI(6, PLED_TYPE_SSR_RB900),
+	.power_led	= PLED(1, PLED_TYPE_SHARED_RB900, PLED_CFG_ON),
+	.pcie_power_off	= PLDI(7, PLED_TYPE_SSR_RB900),
+};
+static struct platform_device rb912g_led_device = {
+	.name	= "rb400-led",
+	.id	= -1,
+	.dev	= {
+		.platform_data = &rb912g_led_map,
+	},
+};
+
+
+
+
+static struct rb400_leds sxt2d_led_map = {
+	.user_led	= PLDI(3, PLED_TYPE_GPIO_OE),
+	.led1		= PLDI(16, PLED_TYPE_GPIO),
+	.led2		= PLDI(21, PLED_TYPE_GPIO),
+	.led3		= PLDI(4, PLED_TYPE_GPIO),
+	.led4		= PLDI(12, PLED_TYPE_GPIO),
+	.led5		= PLDI(13, PLED_TYPE_GPIO),
+	.power_led	= PLDI(11, PLED_TYPE_GPIO_OE),
+	.button		= PLDI(15, PLED_TYPE_GPIO),
+};
+static struct platform_device sxt2d_led_device = {
+	.name	= "rb400-led",
+	.id	= -1,
+	.dev	= {
+		.platform_data = &sxt2d_led_map,
+	},
+};
+
+static struct rb400_leds sxt5n_led_map = {
+	.user_led	= PLDI(3, PLED_TYPE_GPIO_OE),
+	.led1		= PLDI(13, PLED_TYPE_GPIO),
+	.led2		= PLDI(12, PLED_TYPE_GPIO),
+	.led3		= PLDI(4, PLED_TYPE_GPIO),
+	.led4		= PLDI(21, PLED_TYPE_GPIO),
+	.led5		= PLDI(18, PLED_TYPE_GPIO),
+	.usb_power_off	= PLDI(20, PLED_TYPE_GPIO),
+	.power_led	= PLDI(11, PLED_TYPE_GPIO_OE),
+	.button		= PLDI(15, PLED_TYPE_GPIO),
+};
+static struct platform_device sxt5n_led_device = {
+	.name	= "rb400-led",
+	.id	= -1,
+	.dev	= {
+		.platform_data = &sxt5n_led_map,
+	},
+};
+
+static struct platform_device rb500_led_device = {
+	.name	= "rb500-led",
+	.id	= -1,
+};
+
+static struct platform_device cr_led_device = {
+	.name	= "cr-led",
+	.id	= -1,
+};
+
+static struct platform_device mr_led_device = {
+	.name	= "mr-led",
+	.id	= -1,
+};
+
+static struct platform_device ar9340_gpio_device = {
+	.name	= "rb400-gpio",
+	.id	= -1,
+	.dev	= {
+		.platform_data = (void *)RB400_GPIO_INVERT_OE,
+	},
+};
+
+static struct i2c_gpio_platform_data rb2011_i2c_gpio_data = {
+    .sda_pin = 11,
+    .scl_pin = 21,
+    .udelay = 5,
+    .timeout = 1,
+    .sda_is_open_drain = 0,
+    .scl_is_open_drain = 0,
+    .scl_is_output_only = 0,
+};
+static struct platform_device rb2011_i2c_gpio_device = {
+	.name	= "i2c-gpio",
+	.id	= -1,
+	.dev	= {
+		.platform_data = &rb2011_i2c_gpio_data,
+	},
+};
+
+static struct platform_device rb2011_gpio_i2c_sfp_device = {
+	.name	= "rb400-gpio-i2c-sfp",
+	.id	= -1,
+};
+
+
+static int rb411_eth_port_map[] = { 1, 0, 1, -1 };
+static struct platform_device rb411_eth_device = {
+	.name	= "ag7100",
+	.id	= -1,
+	.dev	= {
+		.platform_data = rb411_eth_port_map,
+	},
+};
+
+static int rb411g_eth_port_map[] = { 1, 0, 0, -1 };
+static struct platform_device rb411g_eth_device = {
+	.name	= "ag7100",
+	.id	= -1,
+	.dev	= {
+		.platform_data = rb411g_eth_port_map,
+	},
+};
+
+static int rb433_eth_port_map[] = { 2, 1, 4, -1, 0, 175, 1, 2, -1 };
+static struct platform_device rb433_eth_device = {
+	.name	= "ag7100",
+	.id	= -1,
+	.dev	= {
+		.platform_data = rb433_eth_port_map,
+	},
+};
+
+static int rb433gl_eth_port_map[] = { 1, 0, 8327, 4, 1, 2, -1 };
+static struct platform_device rb433gl_eth_device = {
+	.name	= "ag7100",
+	.id	= -1,
+	.dev	= {
+		.platform_data = rb433gl_eth_port_map,
+	},
+};
+
+
+static int rb433ul_eth_port_map[] = { 2, 1, 4, -1, 0, 8236, 0, 1, -1 };
+static struct platform_device rb433ul_eth_device = {
+	.name	= "ag7100",
+	.id	= -1,
+	.dev	= {
+		.platform_data = rb433ul_eth_port_map,
+	},
+};
+
+static int rb435g_eth_port_map[] = { 2, 1, 4, -1, 0, 8316, 0, 1, -1 };
+static struct platform_device rb435g_eth_device = {
+	.name	= "ag7100",
+	.id	= -1,
+	.dev	= {
+		.platform_data = rb435g_eth_port_map,
+	},
+};
+
+static int rb450_eth_port_map[] = { 2, 1, 4, -1, 0, 175, 3, 2, 1, 0, -1 };
+static struct platform_device rb450_eth_device = {
+	.name	= "ag7100",
+	.id	= -1,
+	.dev	= {
+		.platform_data = rb450_eth_port_map,
+	},
+};
+
+static int rb450g_eth_port_map[] = { 2, 1, 4, -1, 0, 8316, 0, 3, 2, 1, -1 };
+static struct platform_device rb450g_eth_device = {
+	.name	= "ag7100",
+	.id	= -1,
+	.dev	= {
+		.platform_data = rb450g_eth_port_map,
+	},
+};
+
+static int rb711_eth_port_map[] = { 1, 0, 4, -1 };
+static struct platform_device rb711_eth_device = {
+	.name	= "ag7240",
+	.id	= -1,
+	.dev	= {
+		.platform_data = rb711_eth_port_map,
+	},
+};
+
+static int rb711r3_eth_port_map[] = { 1, 1, 7240, 0, -1 };
+static struct platform_device rb711r3_eth_device = {
+	.name	= "ag7240",
+	.id	= -1,
+	.dev	= {
+		.platform_data = rb711r3_eth_port_map,
+	},
+};
+
+static int rb750_eth_port_map[] = { 2, 0, 4, -1, 1, 7240, 3, 2, 1, 0, -1 };
+static struct platform_device rb750_eth_device = {
+	.name	= "ag7240",
+	.id	= -1,
+	.dev	= {
+		.platform_data = rb750_eth_port_map,
+	},
+};
+
+static int rb493g_eth_port_map[] = { 3, 0, 8316, 4, -1,
+				     1, 8316, 1, 2, 3, 0, -1,
+				     0, 8316, 1, 3, 2, 0, -1 };
+static struct platform_device rb493g_eth_device = {
+	.name	= "ag7100",
+	.id	= -1,
+	.dev	= {
+		.platform_data = rb493g_eth_port_map,
+	},
+};
+
+static int rb750g_eth_port_map[] = { 1, 0, 8316, 0, 1, 2, 3, 4, -1 };
+static struct platform_device rb750g_eth_device = {
+	.name	= "ag7100",
+	.id	= -1,
+	.dev	= {
+		.platform_data = rb750g_eth_port_map,
+	},
+};
+
+static int rb711g_eth_port_map[] = { 1, 0, 0, -1 };
+static struct platform_device rb711g_eth_device = {
+	.name	= "ag7240",
+	.id	= -1,
+	.dev	= {
+		.platform_data = rb711g_eth_port_map,
+	},
+};
+
+static int sxt2d_eth_port_map[] = { 1, 1, 8227, 0, -1 };
+static struct platform_device sxt2d_eth_device = {
+	.name	= "ag7240",
+	.id	= -1,
+	.dev	= {
+		.platform_data = sxt2d_eth_port_map,
+	},
+};
+
+static int rb2011S_eth_port_map[] = { 2,
+				      0, 8327, 5, 0, 1, 2, 3, 4, -1,
+				      1, 8227, 4, 3, 2, 1, 0, -1 };
+static struct platform_device rb2011S_eth_device = {
+	.name	= "ag7240",
+	.id	= -1,
+	.dev	= {
+		.platform_data = rb2011S_eth_port_map,
+	},
+};
+
+
+static int rb2011L_eth_port_map[] = { 2,
+				      0, 8327, 0, 1, 2, 3, 4, -1,
+				      1, 8227, 4, 3, 2, 1, 0, -1 };
+static struct platform_device rb2011L_eth_device = {
+	.name	= "ag7240",
+	.id	= -1,
+	.dev	= {
+		.platform_data = rb2011L_eth_port_map,
+	},
+};
+
+static int rb951G_eth_port_map[] = { 1,
+				     0, 8327, 0, 1, 2, 3, 4, -1, };
+static struct platform_device rb951G_eth_device = {
+	.name	= "ag7240",
+	.id	= -1,
+	.dev	= {
+		.platform_data = rb951G_eth_port_map,
+	},
+};
+
+static int rb750gl_eth_port_map[] = { 1, 0, 8327, 0, 1, 2, 3, 4, -1 };
+static struct platform_device rb750gl_eth_device = {
+	.name	= "ag7240",
+	.id	= -1,
+	.dev	= {
+		.platform_data = rb750gl_eth_port_map,
+	},
+};
+
+static int groove52_eth_port_map[] = { 1, 0, 0, -1 };
+static struct platform_device groove52_eth_device = {
+	.name	= "ag7240",
+	.id	= -1,
+	.dev	= {
+		.platform_data = groove52_eth_port_map,
+	},
+};
+
+static int rb912g_eth_port_map[] = { 1, 0, 0, -1 };
+static struct platform_device rb912g_eth_device = {
+	.name	= "ag7240",
+	.id	= -1,
+	.dev	= {
+		.platform_data = rb912g_eth_port_map,
+	},
+};
+
+static int rb493_eth_port_map[] = { 2, 0, 1, -1,
+				    1, 178, 0, 1, 2, 3, 4, 5, 6, 7, -1 };
+static struct platform_device rb493_eth_device = {
+	.name	= "ag7100",
+	.id	= -1,
+	.dev	= {
+		.platform_data = rb493_eth_port_map,
+	},
+};
+
+static int rb112_eth_port_map[] = { -1, 0, -1 };
+
+static struct platform_device rb112_eth_device = {
+	.name	= "admtek",
+	.id	= -1,
+	.dev	= {
+		.platform_data = rb112_eth_port_map,
+	},
+};
+
+static int rb153_eth_port_map[] = { -1, 0, 4, 3, 2, 1, -1 };
+
+static struct platform_device rb153_eth_device = {
+	.name	= "admtek",
+	.id	= -1,
+	.dev	= {
+		.platform_data = rb153_eth_port_map,
+	},
+};
+
+static int rb133_eth_port_map[] = { -1, 2, 1, 0, -1 };
+
+static struct platform_device rb133_eth_device = {
+	.name	= "admtek",
+	.id	= -1,
+	.dev	= {
+		.platform_data = rb133_eth_port_map,
+	},
+};
+
+static int rb133c_eth_port_map[] = { -1, 2, -1 };
+
+static struct platform_device rb133c_eth_device = {
+	.name	= "admtek",
+	.id	= -1,
+	.dev	= {
+		.platform_data = rb133c_eth_port_map,
+	},
+};
+
+static int rb192_eth_port_map[] = { 5, 0, 4, 3, 2, 1, 101, 102, 103, 104, -1 };
+
+static struct platform_device rb192_eth_device = {
+	.name	= "admtek",
+	.id	= -1,
+	.dev	= {
+		.platform_data = rb192_eth_port_map,
+	},
+};
+
+static int mr_eth_port_map[] = { -1, 4, 3, 2, 1, 0, -1 };
+
+static struct platform_device mr_eth_device = {
+	.name	= "admtek",
+	.id	= -1,
+	.dev	= {
+		.platform_data = mr_eth_port_map,
+	},
+};
+
+static struct platform_device cr_eth_device = {
+	.name	= "cr-ether",
+	.id	= -1,
+};
+
+static struct platform_device cr_wlan_device = {
+	.name	= "cr-wlan",
+	.id	= -1,
+};
+
+static struct platform_device ar9330_wlan_device = {
+	.name	= "rb750-wlan",
+	.id	= -1,
+};
+
+static struct platform_device rb500_cf_device = {
+	.name	= "rb500-cf",
+	.id	= -1,
+};
+
+static struct platform_device rb100_cf_device = {
+	.name	= "rb100-cf",
+	.id	= -1,
+};
+
+static u64 dmamask = ~(u32) 0;
+
+static struct resource rb400_ohci_resources[] = {
+	[0] = {
+		.start		= 0x1c000000,
+		.end		= 0x1cffffff,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= 22,
+		.end		= 22,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device rb400_ohci_device = {
+	.name		= "rb400-ohci",
+	.id		= 0,
+	.dev		= {
+		.dma_mask		= &dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+	},
+	.num_resources	= ARRAY_SIZE(rb400_ohci_resources),
+	.resource	= rb400_ohci_resources,
+};
+
+static struct resource rb400_ehci_resources[] = {
+	[0] = {
+		.start		= 0x1b000000,
+		.end		= 0x1bffffff,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= 3,
+		.end		= 3,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device rb400_ehci_device = {
+	.name		= "rb400-ehci",
+	.id		= 0,
+	.dev		= {
+		.dma_mask		= &dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+	},
+	.num_resources	= ARRAY_SIZE(rb400_ehci_resources),
+	.resource	= rb400_ehci_resources,
+};
+
+static struct poeout_port rb2011r5_poeout_port = {
+	.eth_port = 10,
+	.gpo_on = 2,
+	.gpi_status = 13,
+	.gpi_status_valid = 3,
+};
+static struct platform_device rb2011r5_poeout_device = {
+	.name	= "poe-out-simple",
+	.id	= -1,
+	.dev	= {
+		.platform_data = &rb2011r5_poeout_port,
+	},
+};
+
+static struct poeout_port rb2011Lr5_poeout_port = {
+	.eth_port = 9,
+	.gpo_on = 2,
+	.gpi_status = 13,
+	.gpi_status_valid = 3,
+};
+static struct platform_device rb2011Lr5_poeout_device = {
+	.name	= "poe-out-simple",
+	.id	= -1,
+	.dev	= {
+		.platform_data = &rb2011Lr5_poeout_port,
+	},
+};
+
+static struct platform_device *rb112_devices[] = {
+	&rb100_uart_device,
+	&rb100_nand_device,
+	&rb112_eth_device,
+	&flash_nor_device,
+	&rb112_led_device,
+};
+
+static struct platform_device *rb153_devices[] = {
+	&rb100_uart_device,
+	&rb100_nand_device,
+	&rb153_eth_device,
+	&rb100_cf_device,
+	&flash_nor_device,
+	&rb100_led_device,
+};
+
+static struct platform_device *rb133_devices[] = {
+	&rb100_uart_device,
+	&rb100_nand_device,
+	&rb133_eth_device,
+	&flash_nor_device,
+	&rb100_led_device,
+};
+
+static struct platform_device *rb133c_devices[] = {
+	&rb100_uart_device,
+	&rb100_nand_device,
+	&rb133c_eth_device,
+	&flash_nor_device,
+	&rb100_led_device,
+};
+
+static struct platform_device *rb192_devices[] = {
+	&rb100_uart_device,
+	&rb100_nand_device,
+	&rb192_eth_device,
+	&flash_nor_device,
+	&rb100_led_device,
+};
+
+static struct platform_device *mr_devices[] = {
+	&rb100_uart_device,
+	&mr_nand_device,
+	&mr_eth_device,
+	&flash_nor_device,
+	&mr_led_device,
+};
+
+static struct platform_device *rb500_devices[] = {
+	&rb500_nand_device,
+	&korina_device,
+	&rb500_cf_device,
+	&flash_nor_device,
+	&rb500_led_device,
+};
+
+static struct platform_device *rb500r5_devices[] = {
+	&rb500r5_nand_device,
+	&korina_device,
+	&rb500_cf_device,
+	&flash_nor_device,
+	&rb500_led_device,
+};
+
+static struct platform_device *rb411_devices[] = {
+	&rb400_spi_device,
+	&rb411_eth_device,
+	&rb400_led_device,
+};
+
+static struct platform_device *rb411ul_devices[] = {
+	&rb400_ohci_device,
+	&rb400_ehci_device,
+	&rb750_spi_device,
+	&rb750g_nand_device,
+	&rb411_eth_device,
+	&rb411l_led_device,
+};
+
+static struct platform_device *rb411l_devices[] = {
+	&rb750_spi_device,
+	&rb750g_nand_device,
+	&rb411_eth_device,
+	&rb411l_led_device,
+};
+
+static struct platform_device *rb411g_devices[] = {
+	&rb400_ohci_device,
+	&rb400_ehci_device,
+	&rb750_spi_device,
+	&rb750g_nand_device,
+	&rb411g_eth_device,
+	&rb411l_led_device,
+};
+
+static struct platform_device *rb411u_devices[] = {
+	&rb400_ohci_device,
+	&rb400_ehci_device,
+	&rb400_spi_device,
+	&rb411_eth_device,
+	&rb400_led_device,
+};
+
+static struct platform_device *rb433_devices[] = {
+	&rb433_spi_device,
+	&rb433_eth_device,
+	&rb400_led_device,
+};
+
+static struct platform_device *rb433u_devices[] = {
+	&rb400_ohci_device,
+	&rb400_ehci_device,
+	&rb433_spi_device,
+	&rb433_eth_device,
+	&rb400_led_device,
+};
+
+static struct platform_device *rb433gl_devices[] = {
+	&rb400_ohci_device,
+	&rb400_ehci_device,
+	&rb750_spi_device,
+	&rb433gl_eth_device,
+	&rb750g_nand_device,
+	&rb411l_led_device,
+};
+
+static struct platform_device *rb433ul_devices[] = {
+	&rb400_ohci_device,
+	&rb400_ehci_device,
+	&rb750_spi_device,
+	&rb433ul_eth_device,
+	&rb750g_nand_device,
+	&rb411l_led_device,
+};
+
+static struct platform_device *rb433l_devices[] = {
+	&rb750_spi_device,
+	&rb433ul_eth_device,
+	&rb750g_nand_device,
+	&rb411l_led_device,
+};
+
+static struct platform_device *rb435g_devices[] = {
+	&rb400_ohci_device,
+	&rb400_ehci_device,
+	&rb433_spi_device,
+	&rb435g_eth_device,
+	&rb400_led_device,
+};
+
+static struct platform_device *rb450_devices[] = {
+	&rb400_spi_device,
+	&rb450_eth_device,
+	&rb400_led_device,
+};
+
+static struct platform_device *rb450g_devices[] = {
+	&rb433_spi_device,
+	&rb450g_eth_device,
+	&rb450g_led_device,
+};
+
+static struct platform_device *rb493_devices[] = {
+	&rb400_spi_device,
+	&rb493_eth_device,
+	&rb400_led_device,
+};
+
+static struct platform_device *rb493g_devices[] = {
+	&rb400_ohci_device,
+	&rb400_ehci_device,
+	&rb433_spi_device,
+	&rb493g_eth_device,
+	&rb493g_led_device,
+};
+
+static struct platform_device *rb750g_devices[] = {
+	&rb750_spi_device,
+	&rb750g_nand_device,
+	&rb750g_eth_device,
+	&rb750g_led_device,
+};
+
+static struct platform_device *cr_devices[] = {
+	&cr_nand_device,
+	&cr_eth_device,
+	&cr_wlan_device,
+	&flash_spi_device,
+	&cr_led_device,
+};
+
+static struct resource rb700_ohci_resources[] = {
+	[0] = {
+		.start		= 0x1b000000,
+		.end		= 0x1bffffff,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= 3,
+		.end		= 3,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device rb700_ohci_device = {
+	.name		= "rb400-ohci",
+	.id		= 0,
+	.dev		= {
+		.dma_mask		= &dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+	},
+	.num_resources	= ARRAY_SIZE(rb700_ohci_resources),
+	.resource	= rb700_ohci_resources,
+};
+
+static struct resource rb700_ehci_resources[] = {
+	[0] = {
+		.start		= 0x1b000000,
+		.end		= 0x1b3fffff,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= 3,
+		.end		= 3,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device rb700_ehci_device = {
+	.name		= "rb400-ehci",
+	.id		= 0,
+	.dev		= {
+		.dma_mask		= &dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+	},
+	.num_resources	= ARRAY_SIZE(rb700_ehci_resources),
+	.resource	= rb700_ehci_resources,
+};
+
+static struct platform_device *rb711_devices[] = {
+	&rb700_ohci_device,
+	&rb700_ehci_device,
+	&rb711_spi_device,
+	&rb700_nand_device,
+	&rb711_led_device,
+	&rb711_eth_device,
+};
+
+static struct platform_device *rb711r3_devices[] = {
+	&rb700_ohci_device,
+	&rb700_ehci_device,
+	&rb711_spi_device,
+	&rb700_nand_device,
+	&rb711r3_led_device,
+	&rb711r3_eth_device,
+};
+
+static struct platform_device *rb_omni_5fe_devices[] = {
+	&rb700_ohci_device,
+	&rb700_ehci_device,
+	&omni_spi_device,
+	&rb700_nolatch_nand_device,
+	&sxt5d_led_device,
+	&rb750_eth_device,
+};
+
+static struct platform_device *rb751g_devices[] = {
+	&rb700_ohci_device,
+	&rb700_ehci_device,
+	&rb711_spi_device,
+	&rb750gl_eth_device,
+	&rb700_nolatch_nand_device,
+	&rb751g_led_device,
+};
+
+static struct platform_device *rb711g_devices[] = {
+	&rb700_ohci_device,
+	&rb700_ehci_device,
+	&rb711_spi_device,
+	&rb700_nand_device,
+	&rb711g_eth_device,
+	&rb711g_led_device,
+};
+
+static struct platform_device *rb_sxtg_devices[] = {
+	&rb700_ohci_device,
+	&rb700_ehci_device,
+	&rb711_spi_device,
+	&rb700_nolatch_nand_device,
+	&rb711g_eth_device,
+	&sxtg_led_device,
+};
+
+static struct platform_device *rb912g_devices[] = {
+	&rb700_ohci_device,
+	&rb700_ehci_device,
+	&rb2011L_spi_device,
+	&rb912g_eth_device,
+	&ar9342_nand_device,
+	&rb912g_led_device,
+	&ar9330_wlan_device,
+};
+
+static struct platform_device *rb750gl_devices[] = {
+	&rb711_spi_device,
+	&rb700_nolatch_nand_device,
+	&rb750gl_led_device,
+	&rb750gl_eth_device,
+};
+
+
+
+static struct platform_device *sxt2d_devices[] = {
+	&rb700_ohci_device,
+	&rb700_ehci_device,
+	&rb2011L_spi_device,
+	&sxt2d_led_device,
+	&sxt2d_eth_device,
+	&ar9344_nand_device,
+	&ar9330_wlan_device,
+};
+
+static struct platform_device *sxt5n_devices[] = {
+	&rb700_ohci_device,
+	&rb700_ehci_device,
+	&rb2011L_spi_device,
+	&sxt5n_led_device,
+	&sxt2d_eth_device,
+	&ar9344_nand_device,
+	&ar9330_wlan_device,
+};
+
+static struct platform_device *rb2011G_devices[] = {
+	&rb700_ohci_device,
+	&rb700_ehci_device,
+	&rb2011_spi_device,
+	&rb2011S_eth_device,
+	&ar9344_nand_device,
+	&ar9330_wlan_device,
+	&rb2011_led_device,
+};
+
+static struct platform_device *rb2011US_devices[] = {
+	&rb700_ohci_device,
+	&rb700_ehci_device,
+	&rb2011_spi_device,
+	&rb2011S_eth_device,
+	&ar9344_nand_device,
+	&rb2011_led_device,
+};
+
+static struct platform_device *rb2011L_devices[] = {
+	&rb2011L_spi_device,
+	&rb2011L_led_device,
+	&rb2011L_eth_device,
+	&ar9344_nand_device,
+};
+
+static struct platform_device *rb2011LS_devices[] = {
+	&rb2011L_spi_device,
+	&rb2011S_eth_device,
+	&ar9344_nand_device,
+	&rb2011_led_device,
+};
+
+static struct hwopt_device rb2011r5_devices[] = {
+	{ &rb700_ohci_device, HW_OPT_HAS_USB, 0 },
+	{ &rb700_ehci_device, HW_OPT_HAS_USB, 0 },
+	{ &rb2011_spi_device, HW_OPT_HAS_LCD, 0 },
+	{ &rb2011L_spi_device, 0, HW_OPT_HAS_LCD },
+	{ &rb2011r5_poeout_device, HW_OPT_HAS_POE_OUT | HW_OPT_HAS_SFP, 0 },
+	{ &rb2011Lr5_poeout_device, HW_OPT_HAS_POE_OUT, HW_OPT_HAS_SFP },
+	{ &rb2011S_eth_device, HW_OPT_HAS_SFP, 0 },
+	{ &rb2011L_eth_device, 0, HW_OPT_HAS_SFP },
+	{ &ar9344_nand_device, 0, 0 },
+	{ &ar9330_wlan_device, HW_OPT_HAS_WIFI, 0 },
+	{ &rb2011r5_led_device, HW_OPT_HAS_SFP, 0 },
+	{ &rb2011r5_user_led_device, 0, HW_OPT_HAS_SFP },
+	{ &ar9340_gpio_device, 0, 0 },
+	{ &rb2011_i2c_gpio_device, HW_OPT_HAS_SFP, 0 },
+	{ &rb2011_gpio_i2c_sfp_device, HW_OPT_HAS_SFP, 0 },
+};
+
+static struct platform_device *rb951G_devices[] = {
+	&rb700_ohci_device,
+	&rb700_ehci_device,
+	&rb2011_spi_device,
+	&rb951G_eth_device,
+	&ar9344_nand_device,
+	&ar9330_wlan_device,
+	&rb951g_led_device,
+};
+
+
+
+
+static int crs125g_eth_port_map[] = {
+    1, 0, 8513,
+    1, 2, 3, 4, 5, 6, 7, 8,
+    9, 10, 11, 12, 13, 14, 15, 16,
+    17, 18, 19, 20, 21, 22, 23, 24,
+    26,
+    -1
+};
+static struct platform_device crs125g_eth_device = {
+	.name	= "ag7240",
+	.id	= -1,
+	.dev	= {
+		.platform_data = crs125g_eth_port_map,
+	},
+};
+
+static struct platform_device *crs125g_devices[] = {
+	&rb700_ohci_device,
+	&rb700_ehci_device,
+	&rb2011_spi_device,
+	&ar9344_nand_device,
+	&ar9330_wlan_device,
+	&crs125g_eth_device,
+	&crs125_led_device,
+};
+
+static struct rb400_leds groove52_led_map = {
+	.led1		= PLD(0, PLED_TYPE_WIFI),
+	.led2		= PLD(0, PLED_TYPE_SHARED_RB900),
+	.led3		= PLD(1, PLED_TYPE_SHARED_RB900),
+	.led4		= PLD(2, PLED_TYPE_SHARED_RB900),
+};
+static struct platform_device groove52_led_device = {
+	.name	= "rb400-led",
+	.id	= -1,
+	.dev	= {
+		.platform_data = &groove52_led_map,
+	},
+};
+
+static struct platform_device *groove52_devices[] = {
+	&rb750_spi_device,
+	&groove52_eth_device,
+	&ar9342_nand_device,
+	&ar9330_wlan_device,
+	&groove52_led_device,
+};
+
+static struct platform_device ar9330_uart_device = {
+	.name	= "ar9330-uart",
+	.id	= -1,
+};
+static struct platform_device ar9330_nand_device = {
+	.name	= "ar9330-nand",
+	.id	= -1,
+};
+static struct rb400_leds rb951_led_map = {
+	.user_led	= PLD(0, PLED_TYPE_GPIO),
+	.usb_power_off	= PLD(9, PLED_TYPE_GPIO),
+	.button		= PLDI(6, PLED_TYPE_GPIO),
+	.pin_hole	= PLDI(7, PLED_TYPE_GPIO),
+};
+static struct platform_device rb951_led_device = {
+	.name	= "rb400-led",
+	.id	= -1,
+	.dev	= {
+		.platform_data = &rb951_led_map,
+	},
+};
+
+static struct platform_device *rb951_devices[] = {
+	&rb700_ohci_device,
+	&rb700_ehci_device,
+	&rb750_spi_device,
+	&ar9330_nand_device,
+	&ar9330_uart_device,
+	&rb750_eth_device,
+	&rb951_led_device,
+	&ar9330_wlan_device,
+};
+
+
+
+static struct platform_device *rb_sxt5d_devices[] = {
+	&rb700_ohci_device,
+	&rb700_ehci_device,
+	&rb711_spi_device,
+	&rb700_nolatch_nand_device,
+	&sxt5d_led_device,
+	&rb711r3_eth_device
+};
+
+static struct platform_device *rb_groove_devices[] = {
+	&rb700_ohci_device,
+	&rb700_ehci_device,
+	&rb711_spi_device,
+	&rb700_nolatch_nand_device,
+	&groove_led_device,
+	&rb711r3_eth_device
+};
+
+static struct platform_device *rb750_devices[] = {
+	&rb700_ohci_device,
+	&rb700_ehci_device,
+	&omni_spi_device,
+	&rb700_tiny_nand_device,
+	&rb700_led_device,
+	&rb750_eth_device
+};
+
+static struct platform_device *rb751_devices[] = {
+	&rb700_ohci_device,
+	&rb700_ehci_device,
+	&rb711_spi_device,
+	&rb700_tiny_nand_device,
+	&rb751_led_device,
+	&rb750_eth_device
+};
+
+static struct platform_driver fake_serial8250_driver = {
+	.driver = {
+		.name = "serial8250",
+	},
+};
+
+int rb_platform_init(void)
+{
+	switch (mips_machgroup) {
+	case MACH_GROUP_MT_RB100:
+		platform_driver_register(&fake_serial8250_driver);
+
+		switch (mips_machtype) {
+		case MACH_MT_RB100:
+			return platform_add_devices(
+			    rb112_devices, ARRAY_SIZE(rb112_devices));
+		case MACH_MT_RB150:
+			return platform_add_devices(
+			    rb153_devices, ARRAY_SIZE(rb153_devices));
+		case MACH_MT_RB133:
+			return platform_add_devices(
+			    rb133_devices, ARRAY_SIZE(rb133_devices));
+		case MACH_MT_RB133C:
+			return platform_add_devices(
+			    rb133c_devices, ARRAY_SIZE(rb133c_devices));
+		case MACH_MT_RB192:
+			return platform_add_devices(
+			    rb192_devices, ARRAY_SIZE(rb192_devices));
+		case MACH_MT_MR:
+			return platform_add_devices(
+			    mr_devices, ARRAY_SIZE(mr_devices));
+		}
+		break;
+	case MACH_GROUP_MT_RB500:
+		switch (mips_machtype) {
+		case MACH_MT_RB500:
+			return platform_add_devices(
+			    rb500_devices, ARRAY_SIZE(rb500_devices));
+		case MACH_MT_RB500R5:
+			return platform_add_devices(
+			    rb500r5_devices, ARRAY_SIZE(rb500r5_devices));
+		}
+		break;
+	case MACH_GROUP_MT_RB400:
+		switch (mips_machtype) {
+		case MACH_MT_RB411:
+			return platform_add_devices(
+				rb411_devices,  ARRAY_SIZE(rb411_devices));
+		case MACH_MT_RB411L:
+			return platform_add_devices(
+				rb411l_devices,  ARRAY_SIZE(rb411l_devices));
+		case MACH_MT_RB411UL:
+			return platform_add_devices(
+				rb411ul_devices,  ARRAY_SIZE(rb411ul_devices));
+		case MACH_MT_RB411G:
+			return platform_add_devices(
+				rb411g_devices,  ARRAY_SIZE(rb411g_devices));
+		case MACH_MT_RB411U:
+			return platform_add_devices(
+				rb411u_devices,  ARRAY_SIZE(rb411u_devices));
+		case MACH_MT_RB433:
+			return platform_add_devices(
+				rb433_devices,  ARRAY_SIZE(rb433_devices));
+		case MACH_MT_RB433U:
+			return platform_add_devices(
+				rb433u_devices,  ARRAY_SIZE(rb433u_devices));
+		case MACH_MT_RB433GL:
+			return platform_add_devices(
+				rb433gl_devices,  ARRAY_SIZE(rb433gl_devices));
+		case MACH_MT_RB433UL:
+			return platform_add_devices(
+				rb433ul_devices,  ARRAY_SIZE(rb433ul_devices));
+		case MACH_MT_RB433L:
+			return platform_add_devices(
+				rb433l_devices,  ARRAY_SIZE(rb433l_devices));
+		case MACH_MT_RB435G:
+			return platform_add_devices(
+				rb435g_devices,  ARRAY_SIZE(rb435g_devices));
+		case MACH_MT_RB450:
+			return platform_add_devices(
+				rb450_devices,  ARRAY_SIZE(rb450_devices));
+		case MACH_MT_RB450G:
+			return platform_add_devices(
+				rb450g_devices,  ARRAY_SIZE(rb450g_devices));
+		case MACH_MT_RB493:
+			return platform_add_devices(
+				rb493_devices,  ARRAY_SIZE(rb493_devices));
+		case MACH_MT_RB493G:
+			return platform_add_devices(
+				rb493g_devices,  ARRAY_SIZE(rb493g_devices));
+		case MACH_MT_RB750G:
+			return platform_add_devices(
+				rb750g_devices,  ARRAY_SIZE(rb750g_devices));
+		}
+		break;
+	case MACH_GROUP_MT_RB700:
+		switch (mips_machtype) {
+		case MACH_MT_RB_OMNI:
+		case MACH_MT_RB711:
+			return platform_add_devices(
+				rb711_devices,  ARRAY_SIZE(rb711_devices));
+		case MACH_MT_RB711R3:
+			return platform_add_devices(
+				rb711r3_devices,  ARRAY_SIZE(rb711r3_devices));
+		case MACH_MT_RB_GROOVE_5S:
+		case MACH_MT_RB_SXT5D:
+			return platform_add_devices(
+			    rb_sxt5d_devices,  ARRAY_SIZE(rb_sxt5d_devices));
+		case MACH_MT_RB751G:
+			return platform_add_devices(
+			    rb751g_devices,  ARRAY_SIZE(rb751g_devices));
+		case MACH_MT_RB711G:
+			return platform_add_devices(
+			    rb711g_devices,  ARRAY_SIZE(rb711g_devices));
+		case MACH_MT_RB_SXTG:
+			return platform_add_devices(
+			    rb_sxtg_devices,  ARRAY_SIZE(rb_sxtg_devices));
+		case MACH_MT_RB912G:
+			return platform_add_devices(
+			    rb912g_devices, ARRAY_SIZE(rb912g_devices));
+		case MACH_MT_RB750GL:
+			return platform_add_devices(
+			    rb750gl_devices,  ARRAY_SIZE(rb750gl_devices));
+		case MACH_MT_SXT2D:
+			return platform_add_devices(
+			    sxt2d_devices,  ARRAY_SIZE(sxt2d_devices));
+		case MACH_MT_SXT5N:
+			return platform_add_devices(
+			    sxt5n_devices,  ARRAY_SIZE(sxt5n_devices));
+		case MACH_MT_RB951G:
+			return platform_add_devices(
+			    rb951G_devices,  ARRAY_SIZE(rb951G_devices));
+		case MACH_MT_RB2011G:
+			return platform_add_devices(
+			    rb2011G_devices,  ARRAY_SIZE(rb2011G_devices));
+		case MACH_MT_RB2011US:
+			return platform_add_devices(
+			    rb2011US_devices,  ARRAY_SIZE(rb2011US_devices));
+		case MACH_MT_RB2011L:
+			return platform_add_devices(
+			    rb2011L_devices,  ARRAY_SIZE(rb2011L_devices));
+		case MACH_MT_RB2011LS:
+			return platform_add_devices(
+			    rb2011LS_devices,  ARRAY_SIZE(rb2011LS_devices));
+		case MACH_MT_RB2011R5:
+			return platform_add_hwopt_devices(
+			    rb2011r5_devices,  ARRAY_SIZE(rb2011r5_devices));
+		case MACH_MT_CRS125G:
+			return platform_add_devices(
+			    crs125g_devices,  ARRAY_SIZE(crs125g_devices));
+		case MACH_MT_GROOVE52:
+			return platform_add_devices(
+			    groove52_devices,  ARRAY_SIZE(groove52_devices));
+		case MACH_MT_RB951:
+			return platform_add_devices(
+			    rb951_devices,  ARRAY_SIZE(rb951_devices));
+		case MACH_MT_RB_GROOVE:
+			return platform_add_devices(
+			    rb_groove_devices,  ARRAY_SIZE(rb_groove_devices));
+		case MACH_MT_RB750:
+			return platform_add_devices(
+				rb750_devices,  ARRAY_SIZE(rb750_devices));
+		case MACH_MT_RB751:
+			return platform_add_devices(
+				rb751_devices,  ARRAY_SIZE(rb751_devices));
+		case MACH_MT_RB_OMNI_5FE:
+			return platform_add_devices(
+				rb_omni_5fe_devices,
+				ARRAY_SIZE(rb_omni_5fe_devices));
+		}
+		break;
+	case MACH_GROUP_MT_CR:
+		return platform_add_devices(
+		    cr_devices, ARRAY_SIZE(cr_devices));
+	case MACH_GROUP_MT_VM:
+		return 0;
+	}
+
+	printk("ERROR: unknown RB version\n");
+	return 0;
+}
+
+arch_initcall(rb_platform_init);
--- /dev/null
+++ b/arch/mips/rb/prom.c
@@ -0,0 +1,491 @@
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/console.h>
+#include <asm/bootinfo.h>
+#include <asm/rb/boards.h>
+#include <linux/bootmem.h>
+#include <linux/ioport.h>
+#include <linux/ctype.h>
+#include <linux/irq.h>
+#include <linux/initrd.h>
+
+#define FREQ_TAG   "HZ="
+#define BOARD_TAG  "board="
+
+#define SR_NMI	0x00180000
+
+extern void rb500_setup(void);
+extern void rb100_setup(void);
+extern void rb400_setup(void);
+extern void cr_setup(void);
+extern void rbvm_setup(void);
+
+extern char arcs_cmdline[COMMAND_LINE_SIZE];
+
+extern unsigned long totalram_pages;
+extern unsigned long mips_hpt_frequency;
+
+unsigned char mips_mac_address[6];
+
+unsigned long mips_machgroup __read_mostly = 0;
+EXPORT_SYMBOL(mips_machgroup);
+
+static unsigned get_flash_base(void) {
+    switch (mips_machtype) {
+    case MACH_MT_RB951:
+	return 0x1f000000;
+    default:
+	return 0x1fc00000;
+    }
+}
+
+static void nor_read(void *buf, int count, unsigned long offset) {
+    static unsigned char *flash_base = NULL;
+    if (!flash_base) flash_base = ioremap_nocache(get_flash_base(), 0x20000);
+    memcpy(buf, flash_base + offset, count);
+}
+
+static unsigned read_unsigned(unsigned *offset) {
+    unsigned val = 0;
+    nor_read(&val, sizeof(unsigned), *offset);
+    *offset += sizeof(unsigned);
+    return val;    
+}
+
+int read_booter_cfg(unsigned id, void *buf, int amount) {
+    unsigned offset;
+    unsigned hcfg_offset;
+    unsigned hcfg_size;
+    if (mips_machgroup != MACH_GROUP_MT_RB700
+	&& mips_machgroup != MACH_GROUP_MT_RB400) {
+	printk("read_booter_cfg not implemented for this hardware");
+	return -1;
+    }    
+    else {
+	offset = 0x24;
+    }
+    hcfg_offset = read_unsigned(&offset);
+    hcfg_size = read_unsigned(&offset);
+    printk("hcfg_offset=%08x\n", hcfg_offset);
+    printk("hcfg_size=%08x\n", hcfg_size);
+    offset = hcfg_offset;
+    if (read_unsigned(&offset) != 0x64726148) return 0;
+    while (offset < hcfg_offset + hcfg_size) {
+	unsigned data = read_unsigned(&offset);
+	unsigned tag = data & 0xffff;	
+	int len = data >> 16;	
+	if (len == 0 || len > hcfg_size || tag == 0) {
+	    break;
+	} else if (tag == id) {
+	    amount = min(len, amount);
+	    nor_read(buf, amount, offset);
+	    return amount;
+	}
+	offset = offset + len;
+    }
+    return 0;
+}
+
+const char *get_system_type(void)
+{
+	switch (mips_machgroup) {
+	case MACH_GROUP_MT_RB100:
+		switch (mips_machtype) {
+		case MACH_MT_RB100:
+			return "Mikrotik RB100";
+		case MACH_MT_RB150:
+			return "Mikrotik RB150";
+		case MACH_MT_RB133:
+			return "Mikrotik RB133";
+		case MACH_MT_RB133C:
+			return "Mikrotik RB133C";
+		case MACH_MT_RB192:
+			return "Mikrotik RB192";
+		case MACH_MT_MR:
+			return "Mikrotik MR";
+		}
+		break;
+	case MACH_GROUP_MT_RB500:
+		switch (mips_machtype) {
+		case MACH_MT_RB500:
+			return "Mikrotik RB500";
+		case MACH_MT_RB500R5:
+			return "Mikrotik RB500r5";
+		}
+		break;
+	case MACH_GROUP_MT_RB400:
+		switch (mips_machtype) {
+		case MACH_MT_RB411:
+			return "Mikrotik RB411";
+		case MACH_MT_RB411U:
+			return "Mikrotik RB411U";
+		case MACH_MT_RB411L:
+			return "Mikrotik RB411L";
+		case MACH_MT_RB411UL:
+			return "Mikrotik RB411UL";
+		case MACH_MT_RB411G:
+			return "Mikrotik RB411GL";
+		case MACH_MT_RB433:
+			return "Mikrotik RB433";
+		case MACH_MT_RB433U:
+			return "Mikrotik RB433U";
+		case MACH_MT_RB433GL:
+			return "Mikrotik RB433GL";
+		case MACH_MT_RB433UL:
+			return "Mikrotik RB433UL";
+		case MACH_MT_RB433L:
+			return "Mikrotik RB433L";
+		case MACH_MT_RB435G:
+			return "Mikrotik RB435G";
+		case MACH_MT_RB450:
+			return "Mikrotik RB450";
+		case MACH_MT_RB450G:
+			return "Mikrotik RB450G";
+		case MACH_MT_RB493:
+			return "Mikrotik RB493";
+		case MACH_MT_RB750G:
+			return "Mikrotik RB750G";
+		}
+		break;
+	case MACH_GROUP_MT_RB700:
+		switch (mips_machtype) {
+		case MACH_MT_RB711R3:
+		case MACH_MT_RB711:
+			return "Mikrotik RB711";
+		case MACH_MT_RB_SXT5D:
+			return "Mikrotik SXT 5-HnD";
+		case MACH_MT_RB_GROOVE:
+		case MACH_MT_RB_GROOVE_5S:
+			return "Mikrotik Groove-5H";
+		case MACH_MT_RB751G:
+			return "Mikrotik RB751G";
+		case MACH_MT_RB912G:
+			return "Mikrotik RB912G";
+		case MACH_MT_RB711G:
+			return "Mikrotik RB711G";
+		case MACH_MT_RB_SXTG:
+			return "Mikrotik SXT G-5HnD";
+		case MACH_MT_RB750GL:
+			return "Mikrotik RB750GL";
+		case MACH_MT_SXT2D:
+			return "Mikrotik SXT 2nD";
+		case MACH_MT_SXT5N:
+			return "Mikrotik SXT 5nD";
+		case MACH_MT_RB2011G:
+			return "Mikrotik RB2011UAS-2HnD";
+		case MACH_MT_RB2011US:
+			return "Mikrotik RB2011UAS";
+		case MACH_MT_RB2011L:
+			return "Mikrotik RB2011L";
+		case MACH_MT_RB2011LS:
+			return "Mikrotik RB2011LS";
+		case MACH_MT_RB2011R5:
+			return "Mikrotik RB2011";
+		case MACH_MT_CRS125G:
+			return "Mikrotik CRS125G";
+		case MACH_MT_RB951G:
+			return "Mikrotik RB951G";
+		case MACH_MT_RB951:
+			return "Mikrotik RB951-2n";
+		case MACH_MT_GROOVE52:
+			return "Mikrotik Groove 52HPn";
+		case MACH_MT_RB750:
+			return "Mikrotik RB750";
+		case MACH_MT_RB751:
+			return "Mikrotik RB751";
+		case MACH_MT_RB_OMNI:
+		case MACH_MT_RB_OMNI_5FE:
+			return "Mikrotik OmniTIK";
+		}
+		break;
+	case MACH_GROUP_MT_CR:
+		switch (mips_machtype) {
+		case MACH_MT_CR1:
+			return "Mikrotik CR";
+		}
+	case MACH_GROUP_MT_VM:
+		return "Mikrotik VM";
+	}
+	return "unknown routerboard";
+}
+
+void __init prom_init(void)
+{
+	int argc = fw_arg0;
+	char **argv = (char **) fw_arg1;
+	unsigned char board_type[16];
+
+	unsigned i, offset = 0;
+
+	set_io_port_base(KSEG1);
+
+	memset(board_type, 0, sizeof(board_type));
+
+	/* HZ must be parsed here because otherwise is too late */
+	for (i = 0; (i < argc && argv[i] != NULL); i++) {
+		if (strncmp(argv[i], FREQ_TAG, sizeof(FREQ_TAG) - 1) == 0) {
+			mips_hpt_frequency = 
+			    simple_strtoul(argv[i] + sizeof(FREQ_TAG) - 1, 0, 10);
+			continue;
+		}
+		if (strncmp(argv[i], BOARD_TAG, sizeof(BOARD_TAG) - 1) == 0) {
+			strncpy(board_type, argv[i] + sizeof(BOARD_TAG) - 1,
+				sizeof(board_type));
+		}
+		offset += snprintf(arcs_cmdline + offset, sizeof(arcs_cmdline) - offset,
+				   "%s ", argv[i]);
+	}
+
+	if (strncmp(board_type, "500r5", sizeof(board_type)) == 0) {
+		mips_machgroup = MACH_GROUP_MT_RB500;
+		mips_machtype = MACH_MT_RB500R5;
+	} else if (strncmp(board_type, "411", sizeof(board_type)) == 0) {
+		mips_machgroup = MACH_GROUP_MT_RB400;
+		mips_machtype = MACH_MT_RB411;
+	} else if (strncmp(board_type, "411L", sizeof(board_type)) == 0) {
+		mips_machgroup = MACH_GROUP_MT_RB400;
+		mips_machtype = MACH_MT_RB411L;
+	} else if (strncmp(board_type, "411UL", sizeof(board_type)) == 0) {
+		mips_machgroup = MACH_GROUP_MT_RB400;
+		mips_machtype = MACH_MT_RB411UL;
+	} else if (strncmp(board_type, "411G", sizeof(board_type)) == 0) {
+		mips_machgroup = MACH_GROUP_MT_RB400;
+		mips_machtype = MACH_MT_RB411G;
+	} else if (strncmp(board_type, "750G", sizeof(board_type)) == 0) {
+		mips_machgroup = MACH_GROUP_MT_RB400;
+		mips_machtype = MACH_MT_RB750G;
+	} else if (strncmp(board_type, "750i", sizeof(board_type)) == 0) {
+		mips_machgroup = MACH_GROUP_MT_RB700;
+		mips_machtype = MACH_MT_RB750;
+	} else if (strncmp(board_type, "751", sizeof(board_type)) == 0) {
+		mips_machgroup = MACH_GROUP_MT_RB700;
+		mips_machtype = MACH_MT_RB751;
+	} else if (strncmp(board_type, "711r3", sizeof(board_type)) == 0) {
+		mips_machgroup = MACH_GROUP_MT_RB700;
+		mips_machtype = MACH_MT_RB711R3;
+	} else if (strncmp(board_type, "711", sizeof(board_type)) == 0) {
+		mips_machgroup = MACH_GROUP_MT_RB700;
+		mips_machtype = MACH_MT_RB711;
+	} else if (strncmp(board_type, "groove", sizeof(board_type)) == 0) {
+		mips_machgroup = MACH_GROUP_MT_RB700;
+		mips_machtype = MACH_MT_RB_SXT5D;
+	} else if (strncmp(board_type, "751g", sizeof(board_type)) == 0) {
+		mips_machgroup = MACH_GROUP_MT_RB700;
+		mips_machtype = MACH_MT_RB751G;
+	} else if (strncmp(board_type, "711G", sizeof(board_type)) == 0) {
+		mips_machgroup = MACH_GROUP_MT_RB700;
+		mips_machtype = MACH_MT_RB711G;
+	} else if (strncmp(board_type, "SXTG", sizeof(board_type)) == 0) {
+		mips_machgroup = MACH_GROUP_MT_RB700;
+		mips_machtype = MACH_MT_RB_SXTG;
+	} else if (strncmp(board_type, "711Gr100", sizeof(board_type)) == 0) {
+		mips_machgroup = MACH_GROUP_MT_RB700;
+		mips_machtype = MACH_MT_RB912G;
+	} else if (strncmp(board_type, "750Gr3", sizeof(board_type)) == 0) {
+		mips_machgroup = MACH_GROUP_MT_RB700;
+		mips_machtype = MACH_MT_RB750GL;
+	} else if (strncmp(board_type, "sxt2d", sizeof(board_type)) == 0) {
+		mips_machgroup = MACH_GROUP_MT_RB700;
+		mips_machtype = MACH_MT_SXT2D;
+	} else if (strncmp(board_type, "sxt5n", sizeof(board_type)) == 0) {
+		mips_machgroup = MACH_GROUP_MT_RB700;
+		mips_machtype = MACH_MT_SXT5N;
+	} else if (strncmp(board_type, "2011G", sizeof(board_type)) == 0) {
+		mips_machgroup = MACH_GROUP_MT_RB700;
+		mips_machtype = MACH_MT_RB2011G;
+	} else if (strncmp(board_type, "2011US", sizeof(board_type)) == 0) {
+		mips_machgroup = MACH_GROUP_MT_RB700;
+		mips_machtype = MACH_MT_RB2011US;
+	} else if (strncmp(board_type, "2011L", sizeof(board_type)) == 0) {
+		mips_machgroup = MACH_GROUP_MT_RB700;
+		mips_machtype = MACH_MT_RB2011L;
+	} else if (strncmp(board_type, "2011LS", sizeof(board_type)) == 0) {
+		mips_machgroup = MACH_GROUP_MT_RB700;
+		mips_machtype = MACH_MT_RB2011LS;
+	} else if (strncmp(board_type, "2011r5", sizeof(board_type)) == 0) {
+		mips_machgroup = MACH_GROUP_MT_RB700;
+		mips_machtype = MACH_MT_RB2011R5;
+	} else if (strncmp(board_type, "crs125g", sizeof(board_type)) == 0) {
+		mips_machgroup = MACH_GROUP_MT_RB700;
+		mips_machtype = MACH_MT_CRS125G;
+	} else if (strncmp(board_type, "951G", sizeof(board_type)) == 0) {
+		mips_machgroup = MACH_GROUP_MT_RB700;
+		mips_machtype = MACH_MT_RB951G;
+	} else if (strncmp(board_type, "751UL", sizeof(board_type)) == 0) {
+		mips_machgroup = MACH_GROUP_MT_RB700;
+		mips_machtype = MACH_MT_RB951;
+	} else if (strncmp(board_type, "groove-52", sizeof(board_type)) == 0) {
+		mips_machgroup = MACH_GROUP_MT_RB700;
+		mips_machtype = MACH_MT_GROOVE52;
+	} else if (strncmp(board_type, "groove-5", sizeof(board_type)) == 0) {
+		mips_machgroup = MACH_GROUP_MT_RB700;
+		mips_machtype = MACH_MT_RB_GROOVE;
+	} else if (strncmp(board_type, "groove-5s", sizeof(board_type)) == 0) {
+		mips_machgroup = MACH_GROUP_MT_RB700;
+		mips_machtype = MACH_MT_RB_GROOVE_5S;
+	} else if (strncmp(board_type, "omni", sizeof(board_type)) == 0) {
+		mips_machgroup = MACH_GROUP_MT_RB700;
+		mips_machtype = MACH_MT_RB_OMNI;
+	} else if (strncmp(board_type, "omni-5fe", sizeof(board_type)) == 0) {
+		mips_machgroup = MACH_GROUP_MT_RB700;
+		mips_machtype = MACH_MT_RB_OMNI_5FE;
+	} else if (strncmp(board_type, "411U", sizeof(board_type)) == 0) {
+		mips_machgroup = MACH_GROUP_MT_RB400;
+		mips_machtype = MACH_MT_RB411U;
+	} else if (strncmp(board_type, "433", sizeof(board_type)) == 0) {
+		mips_machgroup = MACH_GROUP_MT_RB400;
+		mips_machtype = MACH_MT_RB433;
+	} else if (strncmp(board_type, "433U", sizeof(board_type)) == 0) {
+		mips_machgroup = MACH_GROUP_MT_RB400;
+		mips_machtype = MACH_MT_RB433U;
+	} else if (strncmp(board_type, "433GL", sizeof(board_type)) == 0) {
+		mips_machgroup = MACH_GROUP_MT_RB400;
+		mips_machtype = MACH_MT_RB433GL;
+	} else if (strncmp(board_type, "433UL", sizeof(board_type)) == 0) {
+		mips_machgroup = MACH_GROUP_MT_RB400;
+		mips_machtype = MACH_MT_RB433UL;
+	} else if (strncmp(board_type, "433L", sizeof(board_type)) == 0) {
+		mips_machgroup = MACH_GROUP_MT_RB400;
+		mips_machtype = MACH_MT_RB433L;
+	} else if (strncmp(board_type, "435G", sizeof(board_type)) == 0) {
+		mips_machgroup = MACH_GROUP_MT_RB400;
+		mips_machtype = MACH_MT_RB435G;
+	} else if (strncmp(board_type, "450", sizeof(board_type)) == 0) {
+		mips_machgroup = MACH_GROUP_MT_RB400;
+		mips_machtype = MACH_MT_RB450;
+	} else if (strncmp(board_type, "450G", sizeof(board_type)) == 0) {
+		mips_machgroup = MACH_GROUP_MT_RB400;
+		mips_machtype = MACH_MT_RB450G;
+	} else if (strncmp(board_type, "493G", sizeof(board_type)) == 0) {
+		mips_machgroup = MACH_GROUP_MT_RB400;
+		mips_machtype = MACH_MT_RB493G;
+	} else if (strncmp(board_type, "493", sizeof(board_type)) == 0) {
+		mips_machgroup = MACH_GROUP_MT_RB400;
+		mips_machtype = MACH_MT_RB493;
+	} else if (strncmp(board_type, "100", sizeof(board_type)) == 0) {
+		mips_machgroup = MACH_GROUP_MT_RB100;
+		mips_machtype = MACH_MT_RB100;
+	} else if (strncmp(board_type, "150", sizeof(board_type)) == 0) {
+		mips_machgroup = MACH_GROUP_MT_RB100;
+		mips_machtype = MACH_MT_RB150;
+	} else if (strncmp(board_type, "133", sizeof(board_type)) == 0) {
+		mips_machgroup = MACH_GROUP_MT_RB100;
+		mips_machtype = MACH_MT_RB133;
+	} else if (strncmp(board_type, "133C", sizeof(board_type)) == 0) {
+		mips_machgroup = MACH_GROUP_MT_RB100;
+		mips_machtype = MACH_MT_RB133C;
+	} else if (strncmp(board_type, "192", sizeof(board_type)) == 0) {
+		mips_machgroup = MACH_GROUP_MT_RB100;
+		mips_machtype = MACH_MT_RB192;
+	} else if (strncmp(board_type, "mr", sizeof(board_type)) == 0) {
+		mips_machgroup = MACH_GROUP_MT_RB100;
+		mips_machtype = MACH_MT_MR;
+	} else if (strncmp(board_type, "cr", sizeof(board_type)) == 0) {
+		mips_machgroup = MACH_GROUP_MT_CR;
+		mips_machtype = MACH_MT_CR1;
+	} else if (strncmp(board_type, "vm", sizeof(board_type)) == 0) {
+		mips_machgroup = MACH_GROUP_MT_VM;
+		mips_machtype = 0;
+	} else {
+		mips_machgroup = MACH_GROUP_MT_RB500;
+		mips_machtype = MACH_MT_RB500;
+	}
+}
+
+void __init prom_free_prom_memory(void)
+{
+	unsigned long addr, end;
+	extern char _text;
+
+	/*
+	 * Free everything below the kernel itself but leave
+	 * the first page reserved for the exception handlers.
+	 */
+
+	end = __pa(&_text);
+	addr = PAGE_SIZE;
+
+	while (addr < end) {
+		ClearPageReserved(virt_to_page(__va(addr)));
+		init_page_count(virt_to_page(__va(addr)));
+		free_page((unsigned long)__va(addr));
+		addr += PAGE_SIZE;
+		++totalram_pages;
+	}
+}
+
+void __init plat_mem_setup(void)
+{
+#ifdef CONFIG_BLK_DEV_INITRD
+	extern int _end;
+	u32 *initrd_header;
+
+	initrd_header = __va(PAGE_ALIGN(__pa_symbol(&_end) + 8)) - 8;
+	if (initrd_header[0] == 0x494E5244) {
+		initrd_start = (unsigned long) (initrd_header + 2);
+                initrd_end = initrd_start + initrd_header[1];
+	}
+#endif    
+
+	switch (mips_machgroup) {
+	case MACH_GROUP_MT_RB500:
+		rb500_setup();
+		break;
+	case MACH_GROUP_MT_RB100:
+		rb100_setup();
+		break;
+	case MACH_GROUP_MT_RB400:
+	case MACH_GROUP_MT_RB700:
+		rb400_setup();
+		break;
+	case MACH_GROUP_MT_CR:
+		cr_setup();
+		break;
+	case MACH_GROUP_MT_VM:
+		rbvm_setup();
+		break;
+	}
+}
+
+void __init plat_time_init(void)
+{
+}
+
+static int __init setup_kmac(char *s)
+{
+	int i, j;
+	unsigned char result, value;
+
+	for (i = 0; i < 6; i++) {
+		if (s[0] == '\0' || s[1] == '\0') return 0;
+		if (i != 5 && s[2] != ':') return 0;
+
+		result = 0;
+		for (j = 0; j < 2; j++) {
+			if (!isxdigit(*s)) return 0;
+
+			value = isdigit(*s) ? *s - '0' :
+				toupper(*s) - 'A' + 10;
+			if (value >= 16) return 0;
+
+			result = result * 16 + value;
+                        s++;
+                }
+
+                s++;
+                mips_mac_address[i] = result;
+        }
+
+        return *s == '\0';
+}
+
+__setup("kmac=", setup_kmac);
+
+EXPORT_SYMBOL(mips_mac_address);
+
+unsigned long long sched_clock(void)
+{
+	return read_c0_count() * 1000000000 / mips_hpt_frequency;
+}
--- /dev/null
+++ b/arch/mips/rb/vm/Makefile
@@ -0,0 +1 @@
+obj-y	 := setup.o
--- /dev/null
+++ b/arch/mips/rb/vm/setup.c
@@ -0,0 +1,142 @@
+#include <linux/interrupt.h>
+#include <linux/sched.h>
+#include <asm/reboot.h>
+#include <asm/vm.h>
+#include <asm/rb/boards.h>
+
+#define BUF_SIZE	256
+#define BUF_COUNT	4
+
+hypercall(vm_create_queue, 4, unsigned id, unsigned irq,
+		 unsigned tx, unsigned rx);
+hypercall(vm_release_queue, 5, unsigned id);
+hypercall(vm_running, 6, void);
+hypercall(vm_setup_irqs, 14, unsigned *irqs, unsigned count);
+
+static volatile struct vdma_descr tx_chain[BUF_COUNT];
+static volatile struct vdma_descr rx_chain[BUF_COUNT];
+static unsigned char tx_buffers[BUF_COUNT][BUF_SIZE];
+static unsigned char rx_buffers[BUF_COUNT][BUF_SIZE];
+
+static unsigned cur_tx;
+static unsigned cur_rx;
+
+static int send_message(const unsigned char *buf, int len)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+
+	/* drop some data if full buffer */
+	while (tx_chain[cur_tx].size & DONE)
+		asm volatile ("wait");
+
+	len = min_t(int, len, BUF_SIZE);
+	memcpy(tx_buffers[cur_tx], buf, len);
+	tx_chain[cur_tx].size = len | DONE;
+
+	cur_tx = (cur_tx + 1) % BUF_COUNT;
+
+	local_irq_restore(flags);
+
+	return len;
+}
+
+static int recv_message(char *buf, int len)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+
+	if (!(rx_chain[cur_rx].size & DONE)) {
+		local_irq_restore(flags);
+		return 0;
+	}
+	
+	len = min_t(int, len, rx_chain[cur_rx].size & ~DONE);
+	memcpy(buf, rx_buffers[cur_rx], len);
+
+	rx_chain[cur_rx].size = BUF_SIZE;
+	cur_rx = (cur_rx + 1) % BUF_COUNT;
+
+	local_irq_restore(flags);
+
+	return len;
+}
+
+static irqreturn_t ctrl_interrupt(int irq, void *dev_id)
+{
+	struct task_struct *init;
+	char buf[256];
+	int len;
+
+	len = recv_message(buf, sizeof(buf));
+	if (len <= 0)
+		return IRQ_HANDLED;
+
+	if (strncmp(buf, "restart", len) == 0) {
+		printk("RESTART\n");
+		init = find_task_by_pid_ns(1, &init_pid_ns);
+		if (init)
+			send_sig(SIGINT, init, 1);
+	} else if (strncmp(buf, "halt", len) == 0) {
+	    printk("HALT\n");
+		init = find_task_by_pid_ns(1, &init_pid_ns);
+		if (init)
+			send_sig(SIGWINCH, init, 1);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static void rbvm_machine_restart(char *command)
+{
+	char msg[] = "restart";
+
+	send_message(msg, sizeof(msg));
+}
+
+static void rbvm_machine_halt(void)
+{
+	char msg[] = "halt";
+
+	send_message(msg, sizeof(msg));
+}
+
+void __init rbvm_setup(void)
+{
+	extern unsigned long virqs;
+	int i;
+
+	vm_setup_irqs((unsigned *) &virqs, 32);
+
+	for (i = 0; i < BUF_COUNT; ++i) {
+		rx_chain[i].addr = (unsigned) rx_buffers[i];
+		rx_chain[i].size = BUF_SIZE;
+		rx_chain[i].next = (unsigned) &rx_chain[i + 1];
+		
+		tx_chain[i].addr = (unsigned) tx_buffers[i];
+		tx_chain[i].size = 0;
+		tx_chain[i].next = (unsigned) &tx_chain[i + 1];
+	}
+	rx_chain[BUF_COUNT - 1].next = (unsigned) &rx_chain[0];
+	tx_chain[BUF_COUNT - 1].next = (unsigned) &tx_chain[0];
+
+	vm_create_queue(0, 0, (unsigned) &tx_chain[0],
+			(unsigned) &rx_chain[0]);
+
+	_machine_restart = rbvm_machine_restart;
+	_machine_halt = rbvm_machine_halt;
+}
+
+int __init init_ctrl_interrupt(void)
+{
+	if (mips_machgroup != MACH_GROUP_MT_VM)
+		return 0;
+
+	if (request_irq(VIRQ_BASE + 0, ctrl_interrupt, 0, "ctrl", (void *) 1))
+		return -EBUSY;
+	return 0;
+
+}
+arch_initcall(init_ctrl_interrupt);
--- a/drivers/block/loop.c
+++ b/drivers/block/loop.c
@@ -372,6 +372,9 @@ do_lo_receive(struct loop_device *lo,
 	struct file *file;
 	ssize_t retval;
 
+	pgoff_t index;
+	pgoff_t last_index;
+
 	cookie.lo = lo;
 	cookie.page = bvec->bv_page;
 	cookie.offset = bvec->bv_offset;
@@ -386,6 +389,11 @@ do_lo_receive(struct loop_device *lo,
 	file = lo->lo_backing_file;
 	retval = splice_direct_to_actor(file, &sd, lo_direct_splice_actor);
 
+	/* HACK: try to free up page cache from tripple buffers */
+	index = pos >> PAGE_CACHE_SHIFT;
+	last_index = (pos + bsize + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;
+	invalidate_mapping_pages(file->f_mapping, index, last_index);
+
 	return retval;
 }
 
